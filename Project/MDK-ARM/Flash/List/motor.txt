; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\motor.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\motor.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\motor.crf ..\..\MySrc\motor.cpp]
                          THUMB

                          AREA ||i.MOTOR_SetPWM||, CODE, READONLY, ALIGN=2

                  MOTOR_SetPWM PROC
;;;151    
;;;152    void MOTOR_SetPWM(short pwm,short id)
000000  b530              PUSH     {r4,r5,lr}
;;;153    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;154    
;;;155        CanTxMsg msg_send = { 0, 0, CAN_Id_Standard, CAN_RTR_Data, 0x08,
000008  2214              MOVS     r2,#0x14
00000a  4910              LDR      r1,|L1.76|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;156                             {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55}};
;;;157    	if(pwm < -5000) pwm = -5000;
000012  480f              LDR      r0,|L1.80|
000014  4284              CMP      r4,r0
000016  da00              BGE      |L1.26|
000018  4604              MOV      r4,r0
                  |L1.26|
;;;158    	if(pwm > 5000) pwm = 5000;
00001a  f2413088          MOV      r0,#0x1388
00001e  4284              CMP      r4,r0
000020  dd00              BLE      |L1.36|
000022  4604              MOV      r4,r0
                  |L1.36|
;;;159        // msg_send.StdId = id<<4 | 4;
;;;160        // msg_send.Data[0] = (unsigned char)((5000>>8)&0xff);
;;;161        // msg_send.Data[1] = (unsigned char)(5000&0xff);
;;;162        // msg_send.Data[2] = (unsigned char)((pwm/10>>8)&0xff);
;;;163        // msg_send.Data[3] = (unsigned char)(pwm/10&0xff);
;;;164        // CAN_send(CAN1,&msg_send);
;;;165    	msg_send.StdId = id<<4 | 2;
000024  2002              MOVS     r0,#2
000026  eb001005          ADD      r0,r0,r5,LSL #4
00002a  9000              STR      r0,[sp,#0]
;;;166        msg_send.Data[0] = (pwm>>8)&0xff;
00002c  0a20              LSRS     r0,r4,#8
00002e  f88d000b          STRB     r0,[sp,#0xb]
;;;167        msg_send.Data[1] = (unsigned char)(pwm&0xff);
000032  b2e1              UXTB     r1,r4
000034  f88d100c          STRB     r1,[sp,#0xc]
;;;168    	while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
000038  bf00              NOP      
                  |L1.58|
00003a  4669              MOV      r1,sp
00003c  4805              LDR      r0,|L1.84|
00003e  f7fffffe          BL       CAN_Transmit
000042  2804              CMP      r0,#4
000044  d0f9              BEQ      |L1.58|
;;;169    //	CAN_send(CAN1,&msg_send);
;;;170    }
000046  b005              ADD      sp,sp,#0x14
000048  bd30              POP      {r4,r5,pc}
;;;171    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      ||.constdata||+0x50
                  |L1.80|
                          DCD      0xffffec78
                  |L1.84|
                          DCD      0x40006400

                          AREA ||i.Motor||, CODE, READONLY, ALIGN=1

                  Motor PROC
;;;82     }
;;;83     void Motor(int *MotorData,u8 motorx,int power)
000000  f8503021          LDR      r3,[r0,r1,LSL #2]
;;;84     {
;;;85         MotorData[motorx] += power;
000004  4413              ADD      r3,r3,r2
000006  f8403021          STR      r3,[r0,r1,LSL #2]
;;;86     }
00000a  4770              BX       lr
;;;87     
                          ENDP


                          AREA ||i.Motor_Aguest||, CODE, READONLY, ALIGN=2

                  Motor_Aguest PROC
;;;12      */
;;;13     void Motor_Aguest(u16 Ax,u16 Ay,float Az,float _mAngle)
000000  b570              PUSH     {r4-r6,lr}
;;;14     {
000002  ed2d8b08          VPUSH    {d8-d11}
000006  b084              SUB      sp,sp,#0x10
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
00000c  eef08a40          VMOV.F32 s17,s0
000010  eeb08a60          VMOV.F32 s16,s1
;;;15     //	static u8 count;
;;;16         int MotorData[4]={0};
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
000018  9001              STR      r0,[sp,#4]
00001a  9002              STR      r0,[sp,#8]
00001c  9003              STR      r0,[sp,#0xc]
;;;17     	float xpower,ypower,zpower;
;;;18     	float AxChange,AyChange;
;;;19         AxChange = ((float)Ax - 1024.0f)*No1;
00001e  ee004a10          VMOV     s0,r4
000022  eeb80a40          VCVT.F32.U32 s0,s0
000026  eddf0a37          VLDR     s1,|L3.260|
00002a  ee300a60          VSUB.F32 s0,s0,s1
00002e  eef10a0c          VMOV.F32 s1,#7.00000000
000032  ee200a20          VMUL.F32 s0,s0,s1
000036  eeb09a40          VMOV.F32 s18,s0
;;;20         AyChange = ((float)Ay - 1024.0f)*No1;
00003a  ee005a10          VMOV     s0,r5
00003e  eeb80a40          VCVT.F32.U32 s0,s0
000042  eddf0a30          VLDR     s1,|L3.260|
000046  ee300a60          VSUB.F32 s0,s0,s1
00004a  eef10a0c          VMOV.F32 s1,#7.00000000
00004e  ee200a20          VMUL.F32 s0,s0,s1
000052  eef09a40          VMOV.F32 s19,s0
;;;21     
;;;22         xpower = ((float)AyChange*arm_sin_f32(_mAngle*0.0174532f)+(float)AxChange*arm_cos_f32(_mAngle*0.0174532f));
000056  eddf0a2c          VLDR     s1,|L3.264|
00005a  ee680a20          VMUL.F32 s1,s16,s1
00005e  eeb00a60          VMOV.F32 s0,s1
000062  f7fffffe          BL       arm_sin_f32
000066  ee60ba29          VMUL.F32 s23,s0,s19
00006a  eddf0a27          VLDR     s1,|L3.264|
00006e  ee680a20          VMUL.F32 s1,s16,s1
000072  eeb00a60          VMOV.F32 s0,s1
000076  f7fffffe          BL       arm_cos_f32
00007a  ee49ba00          VMLA.F32 s23,s18,s0
00007e  eeb0aa6b          VMOV.F32 s20,s23
;;;23         ypower = ((float)AyChange*arm_cos_f32(_mAngle*0.0174532f)-(float)AxChange*arm_sin_f32(_mAngle*0.0174532f));
000082  eddf0a21          VLDR     s1,|L3.264|
000086  ee680a20          VMUL.F32 s1,s16,s1
00008a  eeb00a60          VMOV.F32 s0,s1
00008e  f7fffffe          BL       arm_cos_f32
000092  ee60ba29          VMUL.F32 s23,s0,s19
000096  eddf0a1c          VLDR     s1,|L3.264|
00009a  ee680a20          VMUL.F32 s1,s16,s1
00009e  eeb00a60          VMOV.F32 s0,s1
0000a2  f7fffffe          BL       arm_sin_f32
0000a6  ee49ba40          VMLS.F32 s23,s18,s0
0000aa  eef0aa6b          VMOV.F32 s21,s23
;;;24     	zpower = Az;
0000ae  eeb0ba68          VMOV.F32 s22,s17
;;;25     //	zpower  = (int)(((float)Az - 1024.0f)*No1);//(Az - 1024)*No1;
;;;26     
;;;27         X_Axic(MotorData,xpower);
0000b2  eebd0aca          VCVT.S32.F32 s0,s20
0000b6  ee101a10          VMOV     r1,s0
0000ba  4668              MOV      r0,sp
0000bc  f7fffffe          BL       X_Axic
;;;28         Y_Axic(MotorData,ypower);
0000c0  eebd0aea          VCVT.S32.F32 s0,s21
0000c4  ee101a10          VMOV     r1,s0
0000c8  4668              MOV      r0,sp
0000ca  f7fffffe          BL       Y_Axic
;;;29         Z_Axic(MotorData,zpower);
0000ce  eebd0acb          VCVT.S32.F32 s0,s22
0000d2  ee101a10          VMOV     r1,s0
0000d6  4668              MOV      r0,sp
0000d8  f7fffffe          BL       Z_Axic
;;;30     	Motor_DataScale(MotorData,5000);
0000dc  f2413188          MOV      r1,#0x1388
0000e0  4668              MOV      r0,sp
0000e2  f7fffffe          BL       Motor_DataScale
;;;31     //	u1_printf("%d\t%d\t%d\t%d\r\n\r\n",MotorData[Motor1],MotorData[Motor2],MotorData[Motor3],MotorData[Motor4]);
;;;32         Motor_CarFrame(MotorData[Motor1],MotorData[Motor2],MotorData[Motor3],MotorData[Motor4]);//经过Can给底盘4个电机发送的向量相加后的值
0000e6  9e03              LDR      r6,[sp,#0xc]
0000e8  b233              SXTH     r3,r6
0000ea  9e02              LDR      r6,[sp,#8]
0000ec  b232              SXTH     r2,r6
0000ee  9e01              LDR      r6,[sp,#4]
0000f0  b231              SXTH     r1,r6
0000f2  9e00              LDR      r6,[sp,#0]
0000f4  b230              SXTH     r0,r6
0000f6  f7fffffe          BL       Motor_CarFrame
;;;33     
;;;34     }
0000fa  b004              ADD      sp,sp,#0x10
0000fc  ecbd8b08          VPOP     {d8-d11}
000100  bd70              POP      {r4-r6,pc}
;;;35     
                          ENDP

000102  0000              DCW      0x0000
                  |L3.260|
000104  44800000          DCFS     0x44800000 ; 1024
                  |L3.264|
000108  3c8efa03          DCFS     0x3c8efa03 ; 0.017453199252486229

                          AREA ||i.Motor_CarFrame||, CODE, READONLY, ALIGN=2

                  Motor_CarFrame PROC
;;;88     
;;;89     void Motor_CarFrame(int16_t current_201,int16_t current_202,int16_t current_203,int16_t current_204)
000000  b5f0              PUSH     {r4-r7,lr}
;;;90     {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;91         CanTxMsg msg_send = { 0x110, 0x110, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
00000c  2214              MOVS     r2,#0x14
00000e  4912              LDR      r1,|L4.88|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;92     
;;;93     	// msg_send.StdId = 0x110 + 0;
;;;94         msg_send.Data[0] = (unsigned char)(current_201 >> 8);
000016  0a20              LSRS     r0,r4,#8
000018  f88d000b          STRB     r0,[sp,#0xb]
;;;95         msg_send.Data[1] = (unsigned char)current_201;
00001c  b2e1              UXTB     r1,r4
00001e  f88d100c          STRB     r1,[sp,#0xc]
;;;96         msg_send.Data[2] = (unsigned char)(current_202 >> 8);
000022  0a29              LSRS     r1,r5,#8
000024  f88d100d          STRB     r1,[sp,#0xd]
;;;97         msg_send.Data[3] = (unsigned char)current_202;
000028  b2e9              UXTB     r1,r5
00002a  f88d100e          STRB     r1,[sp,#0xe]
;;;98         msg_send.Data[4] = (unsigned char)(current_203 >> 8);
00002e  0a31              LSRS     r1,r6,#8
000030  f88d100f          STRB     r1,[sp,#0xf]
;;;99         msg_send.Data[5] = (unsigned char)current_203;
000034  b2f1              UXTB     r1,r6
000036  f88d1010          STRB     r1,[sp,#0x10]
;;;100        msg_send.Data[6] = (unsigned char)(current_204 >> 8);
00003a  0a39              LSRS     r1,r7,#8
00003c  f88d1011          STRB     r1,[sp,#0x11]
;;;101        msg_send.Data[7] = (unsigned char)current_204;
000040  b2f9              UXTB     r1,r7
000042  f88d1012          STRB     r1,[sp,#0x12]
;;;102    	while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
000046  bf00              NOP      
                  |L4.72|
000048  4669              MOV      r1,sp
00004a  4804              LDR      r0,|L4.92|
00004c  f7fffffe          BL       CAN_Transmit
000050  2804              CMP      r0,#4
000052  d0f9              BEQ      |L4.72|
;;;103    //    CAN_send(CAN1, &msg_send);
;;;104    }
000054  b005              ADD      sp,sp,#0x14
000056  bdf0              POP      {r4-r7,pc}
;;;105    
                          ENDP

                  |L4.88|
                          DCD      ||.constdata||
                  |L4.92|
                          DCD      0x40006400

                          AREA ||i.Motor_DataScale||, CODE, READONLY, ALIGN=1

                  Motor_DataScale PROC
;;;60     }
;;;61     void Motor_DataScale(int *MotorData,int max)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
000002  ed2d8b02          VPUSH    {d8}
000006  b084              SUB      sp,sp,#0x10
000008  4604              MOV      r4,r0
00000a  460e              MOV      r6,r1
;;;63         int TempBuf[4]={0};
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  9001              STR      r0,[sp,#4]
000012  9002              STR      r0,[sp,#8]
000014  9003              STR      r0,[sp,#0xc]
;;;64         u8 k;
;;;65         float scale;
;;;66         for ( k = 0; k < 4; k++)
000016  2500              MOVS     r5,#0
000018  e00d              B        |L5.54|
                  |L5.26|
;;;67         {
;;;68             TempBuf[k] = myabs(MotorData[k]);
00001a  f8540025          LDR      r0,[r4,r5,LSL #2]
00001e  2800              CMP      r0,#0
000020  dd02              BLE      |L5.40|
000022  f8540025          LDR      r0,[r4,r5,LSL #2]
000026  e002              B        |L5.46|
                  |L5.40|
000028  f8540025          LDR      r0,[r4,r5,LSL #2]
00002c  4240              RSBS     r0,r0,#0
                  |L5.46|
00002e  f84d0025          STR      r0,[sp,r5,LSL #2]
000032  1c68              ADDS     r0,r5,#1              ;66
000034  b2c5              UXTB     r5,r0                 ;66
                  |L5.54|
000036  2d04              CMP      r5,#4                 ;66
000038  dbef              BLT      |L5.26|
;;;69         }
;;;70     //	u1_printf("%d\t%d\t%d\t%d\r\n",TempBuf[0],TempBuf[1],TempBuf[2],TempBuf[3]);
;;;71     	bubble_sort(TempBuf,4);
00003a  2104              MOVS     r1,#4
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       _Z11bubble_sortIiEvPT_i ; void bubble_sort<int>(T1*, int)
;;;72     //    u1_printf("%d\t%d\t%d\t%d\r\n",TempBuf[0],TempBuf[1],TempBuf[2],TempBuf[3]);
;;;73         if(TempBuf[3] >= max)
000042  9803              LDR      r0,[sp,#0xc]
000044  42b0              CMP      r0,r6
000046  db0a              BLT      |L5.94|
;;;74             scale = ((float)max)/((float)TempBuf[3]);
000048  ed9d0a03          VLDR     s0,[sp,#0xc]
00004c  eef80ac0          VCVT.F32.S32 s1,s0
000050  ee006a10          VMOV     s0,r6
000054  eeb80ac0          VCVT.F32.S32 s0,s0
000058  ee808a20          VDIV.F32 s16,s0,s1
00005c  e001              B        |L5.98|
                  |L5.94|
;;;75         else
;;;76             scale = 1.0f;
00005e  eeb78a00          VMOV.F32 s16,#1.00000000
                  |L5.98|
;;;77     //	u1_printf("%d\t%d\t%d\t%d\r\n",(int)(((float)TempBuf[0])*scale),(int)(((float)TempBuf[1])*scale),(int)(((float)TempBuf[2])*scale),(int)(((float)TempBuf[3])*scale));
;;;78         MotorData[Motor1] =  (int)(((float)MotorData[Motor1]) * scale);
000062  ed940a00          VLDR     s0,[r4,#0]
000066  eeb80ac0          VCVT.F32.S32 s0,s0
00006a  ee200a08          VMUL.F32 s0,s0,s16
00006e  eebd0ac0          VCVT.S32.F32 s0,s0
000072  ed840a00          VSTR     s0,[r4,#0]
;;;79         MotorData[Motor2] =  (int)(((float)MotorData[Motor2]) * scale);
000076  ed940a01          VLDR     s0,[r4,#4]
00007a  eeb80ac0          VCVT.F32.S32 s0,s0
00007e  ee200a08          VMUL.F32 s0,s0,s16
000082  eebd0ac0          VCVT.S32.F32 s0,s0
000086  ed840a01          VSTR     s0,[r4,#4]
;;;80         MotorData[Motor3] =  (int)(((float)MotorData[Motor3]) * scale);
00008a  ed940a02          VLDR     s0,[r4,#8]
00008e  eeb80ac0          VCVT.F32.S32 s0,s0
000092  ee200a08          VMUL.F32 s0,s0,s16
000096  eebd0ac0          VCVT.S32.F32 s0,s0
00009a  ed840a02          VSTR     s0,[r4,#8]
;;;81         MotorData[Motor4] =  (int)(((float)MotorData[Motor4]) * scale);
00009e  ed940a03          VLDR     s0,[r4,#0xc]
0000a2  eeb80ac0          VCVT.F32.S32 s0,s0
0000a6  ee200a08          VMUL.F32 s0,s0,s16
0000aa  eebd0ac0          VCVT.S32.F32 s0,s0
0000ae  ed840a03          VSTR     s0,[r4,#0xc]
;;;82     }
0000b2  b004              ADD      sp,sp,#0x10
0000b4  ecbd8b02          VPOP     {d8}
0000b8  bd70              POP      {r4-r6,pc}
;;;83     void Motor(int *MotorData,u8 motorx,int power)
                          ENDP


                          AREA ||i.Motor_GetMassage||, CODE, READONLY, ALIGN=2

                  Motor_GetMassage PROC
;;;140    
;;;141    void Motor_GetMassage(u16 index)
000000  b510              PUSH     {r4,lr}
;;;142    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;143        CanTxMsg msg_send = { 0x130, 0x130, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
000006  2214              MOVS     r2,#0x14
000008  490b              LDR      r1,|L6.56|
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;144    
;;;145        msg_send.Data[0] = 0x55;
000010  2055              MOVS     r0,#0x55
000012  f88d000f          STRB     r0,[sp,#0xf]
;;;146        msg_send.Data[1] = 0xaa;
000016  21aa              MOVS     r1,#0xaa
000018  f88d1010          STRB     r1,[sp,#0x10]
;;;147        msg_send.Data[2] = (index>>8)&0xff;
00001c  0a21              LSRS     r1,r4,#8
00001e  f88d1011          STRB     r1,[sp,#0x11]
;;;148        msg_send.Data[3] = index&0xff;
000022  f88d4012          STRB     r4,[sp,#0x12]
;;;149        while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
000026  bf00              NOP      
                  |L6.40|
000028  a901              ADD      r1,sp,#4
00002a  4804              LDR      r0,|L6.60|
00002c  f7fffffe          BL       CAN_Transmit
000030  2804              CMP      r0,#4
000032  d0f9              BEQ      |L6.40|
;;;150    }
000034  b006              ADD      sp,sp,#0x18
000036  bd10              POP      {r4,pc}
;;;151    
                          ENDP

                  |L6.56|
                          DCD      ||.constdata||+0x3c
                  |L6.60|
                          DCD      0x40006400

                          AREA ||i.Motor_Other||, CODE, READONLY, ALIGN=2

                  Motor_Other PROC
;;;124    }
;;;125    void Motor_Other(int16_t current_201,int16_t current_202,int16_t current_203,int16_t current_204)
000000  b5f0              PUSH     {r4-r7,lr}
;;;126    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;127        CanTxMsg msg_send = { 0x02, 0x02, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
00000c  2214              MOVS     r2,#0x14
00000e  4912              LDR      r1,|L7.88|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;128    
;;;129        msg_send.Data[0] = (unsigned char)(current_201 >> 8);
000016  0a20              LSRS     r0,r4,#8
000018  f88d000b          STRB     r0,[sp,#0xb]
;;;130        msg_send.Data[1] = (unsigned char)current_201;
00001c  b2e1              UXTB     r1,r4
00001e  f88d100c          STRB     r1,[sp,#0xc]
;;;131        msg_send.Data[2] = (unsigned char)(current_202 >> 8);
000022  0a29              LSRS     r1,r5,#8
000024  f88d100d          STRB     r1,[sp,#0xd]
;;;132        msg_send.Data[3] = (unsigned char)current_202;
000028  b2e9              UXTB     r1,r5
00002a  f88d100e          STRB     r1,[sp,#0xe]
;;;133        msg_send.Data[4] = (unsigned char)(current_203 >> 8);
00002e  0a31              LSRS     r1,r6,#8
000030  f88d100f          STRB     r1,[sp,#0xf]
;;;134        msg_send.Data[5] = (unsigned char)current_203;
000034  b2f1              UXTB     r1,r6
000036  f88d1010          STRB     r1,[sp,#0x10]
;;;135        msg_send.Data[6] = (unsigned char)(current_204 >> 8);
00003a  0a39              LSRS     r1,r7,#8
00003c  f88d1011          STRB     r1,[sp,#0x11]
;;;136        msg_send.Data[7] = (unsigned char)current_204;
000040  b2f9              UXTB     r1,r7
000042  f88d1012          STRB     r1,[sp,#0x12]
;;;137        while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
000046  bf00              NOP      
                  |L7.72|
000048  4669              MOV      r1,sp
00004a  4804              LDR      r0,|L7.92|
00004c  f7fffffe          BL       CAN_Transmit
000050  2804              CMP      r0,#4
000052  d0f9              BEQ      |L7.72|
;;;138    }
000054  b005              ADD      sp,sp,#0x14
000056  bdf0              POP      {r4-r7,pc}
;;;139    
                          ENDP

                  |L7.88|
                          DCD      ||.constdata||+0x28
                  |L7.92|
                          DCD      0x40006400

                          AREA ||i.Motor_Power||, CODE, READONLY, ALIGN=2

                  Motor_Power PROC
;;;105    
;;;106    void Motor_Power(u16 id,u16 current,u16 volate)
000000  b570              PUSH     {r4-r6,lr}
;;;107    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;108        CanTxMsg msg_send = { 0, 0, CAN_Id_Standard, CAN_RTR_Data, 0x08, {0, 0, 0, 0, 0, 0, 0, 0}};
00000a  2214              MOVS     r2,#0x14
00000c  4910              LDR      r1,|L8.80|
00000e  a801              ADD      r0,sp,#4
000010  f7fffffe          BL       __aeabi_memcpy4
;;;109    	
;;;110    	msg_send.StdId = 0x131;
000014  f2401031          MOV      r0,#0x131
000018  9001              STR      r0,[sp,#4]
;;;111        msg_send.Data[0] = 0x55;
00001a  2055              MOVS     r0,#0x55
00001c  f88d000f          STRB     r0,[sp,#0xf]
;;;112        msg_send.Data[1] = 0xaa;
000020  21aa              MOVS     r1,#0xaa
000022  f88d1010          STRB     r1,[sp,#0x10]
;;;113        msg_send.Data[2] = (u8)((id>>8)&0xff);
000026  0a21              LSRS     r1,r4,#8
000028  f88d1011          STRB     r1,[sp,#0x11]
;;;114        msg_send.Data[3] = (u8)(id&0xff);
00002c  f88d4012          STRB     r4,[sp,#0x12]
;;;115        msg_send.Data[4] = (u8)((volate>>8)&0xff);
000030  0a31              LSRS     r1,r6,#8
000032  f88d1013          STRB     r1,[sp,#0x13]
;;;116    	
;;;117        msg_send.Data[5] = (u8)((current>>8)&0xff);
000036  0a29              LSRS     r1,r5,#8
000038  f88d1014          STRB     r1,[sp,#0x14]
;;;118        msg_send.Data[6] = (u8)(current&0xff);
00003c  f88d5015          STRB     r5,[sp,#0x15]
;;;119    	
;;;120        msg_send.Data[7] = (u8)(volate);
000040  f88d6016          STRB     r6,[sp,#0x16]
;;;121    	CAN_Transmit(CAN1,&msg_send);
000044  a901              ADD      r1,sp,#4
000046  4803              LDR      r0,|L8.84|
000048  f7fffffe          BL       CAN_Transmit
;;;122    //    while(CAN_Transmit(CAN1,&msg_send) == CAN_TxStatus_NoMailBox);
;;;123    
;;;124    }
00004c  b006              ADD      sp,sp,#0x18
00004e  bd70              POP      {r4-r6,pc}
;;;125    void Motor_Other(int16_t current_201,int16_t current_202,int16_t current_203,int16_t current_204)
                          ENDP

                  |L8.80|
                          DCD      ||.constdata||+0x14
                  |L8.84|
                          DCD      0x40006400

                          AREA ||i.Motor_PwmValSet||, CODE, READONLY, ALIGN=2

                  Motor_PwmValSet PROC
;;;189    
;;;190    void Motor_PwmValSet(float motorout[])
000000  b530              PUSH     {r4,r5,lr}
;;;191    {
000002  b087              SUB      sp,sp,#0x1c
000004  4605              MOV      r5,r0
;;;192    	unsigned char i=0;
000006  2400              MOVS     r4,#0
;;;193    	float thr[6]={0.0f};
000008  2118              MOVS     r1,#0x18
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;194    	for(i=0;i<6;i++)
000010  bf00              NOP      
000012  e00e              B        |L9.50|
                  |L9.20|
;;;195    	{
;;;196    		thr[i]=motorout[i]*55;
000014  eb050084          ADD      r0,r5,r4,LSL #2
000018  ed900a00          VLDR     s0,[r0,#0]
00001c  eddf0a58          VLDR     s1,|L9.384|
000020  ee200a20          VMUL.F32 s0,s0,s1
000024  a801              ADD      r0,sp,#4
000026  eb000084          ADD      r0,r0,r4,LSL #2
00002a  ed800a00          VSTR     s0,[r0,#0]
00002e  1c60              ADDS     r0,r4,#1              ;194
000030  b2c4              UXTB     r4,r0                 ;194
                  |L9.50|
000032  2c06              CMP      r4,#6                 ;194
000034  dbee              BLT      |L9.20|
;;;197    	}
;;;198    	PWM1=1300+thr[0];
000036  ed9d0a01          VLDR     s0,[sp,#4]
00003a  eddf0a52          VLDR     s1,|L9.388|
00003e  ee300a20          VADD.F32 s0,s0,s1
000042  eebc0ac0          VCVT.U32.F32 s0,s0
000046  ee100a10          VMOV     r0,s0
00004a  f04f4180          MOV      r1,#0x40000000
00004e  6348              STR      r0,[r1,#0x34]
;;;199    	PWM2=1300+thr[1];
000050  ed9d0a02          VLDR     s0,[sp,#8]
000054  eddf0a4b          VLDR     s1,|L9.388|
000058  ee300a20          VADD.F32 s0,s0,s1
00005c  eebc0ac0          VCVT.U32.F32 s0,s0
000060  ee100a10          VMOV     r0,s0
000064  6388              STR      r0,[r1,#0x38]
;;;200    	PWM3=1300+thr[2];//加30补偿
000066  ed9d0a03          VLDR     s0,[sp,#0xc]
00006a  eddf0a46          VLDR     s1,|L9.388|
00006e  ee300a20          VADD.F32 s0,s0,s1
000072  eebc0ac0          VCVT.U32.F32 s0,s0
000076  ee100a10          VMOV     r0,s0
00007a  63c8              STR      r0,[r1,#0x3c]
;;;201    	PWM4=1300+thr[3];
00007c  ed9d0a04          VLDR     s0,[sp,#0x10]
000080  eddf0a40          VLDR     s1,|L9.388|
000084  ee300a20          VADD.F32 s0,s0,s1
000088  eebc0ac0          VCVT.U32.F32 s0,s0
00008c  ee100a10          VMOV     r0,s0
000090  6408              STR      r0,[r1,#0x40]
;;;202    	if(PWM1>_FLY_MAX_OUT)	PWM1=_FLY_MAX_OUT+30;
000092  4608              MOV      r0,r1
000094  6b40              LDR      r0,[r0,#0x34]
000096  f24051aa          MOV      r1,#0x5aa
00009a  4288              CMP      r0,r1
00009c  d903              BLS      |L9.166|
00009e  f44f60b9          MOV      r0,#0x5c8
0000a2  06c1              LSLS     r1,r0,#27
0000a4  6348              STR      r0,[r1,#0x34]
                  |L9.166|
;;;203    	if(PWM1<1200.0f)					PWM1=1200.0f;
0000a6  f04f4080          MOV      r0,#0x40000000
0000aa  6b40              LDR      r0,[r0,#0x34]
0000ac  ee000a10          VMOV     s0,r0
0000b0  eeb80a40          VCVT.F32.U32 s0,s0
0000b4  eddf0a34          VLDR     s1,|L9.392|
0000b8  eeb40ae0          VCMPE.F32 s0,s1
0000bc  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000c0  d204              BCS      |L9.204|
0000c2  f44f6096          MOV      r0,#0x4b0
0000c6  f04f4180          MOV      r1,#0x40000000
0000ca  6348              STR      r0,[r1,#0x34]
                  |L9.204|
;;;204    	if(PWM2>_FLY_MAX_OUT)	PWM2=_FLY_MAX_OUT;
0000cc  f04f4080          MOV      r0,#0x40000000
0000d0  6b80              LDR      r0,[r0,#0x38]
0000d2  f24051aa          MOV      r1,#0x5aa
0000d6  4288              CMP      r0,r1
0000d8  d902              BLS      |L9.224|
0000da  4608              MOV      r0,r1
0000dc  0741              LSLS     r1,r0,#29
0000de  6388              STR      r0,[r1,#0x38]
                  |L9.224|
;;;205    	if(PWM2<1200.0f)					PWM2=1200.0f;
0000e0  f04f4080          MOV      r0,#0x40000000
0000e4  6b80              LDR      r0,[r0,#0x38]
0000e6  ee000a10          VMOV     s0,r0
0000ea  eeb80a40          VCVT.F32.U32 s0,s0
0000ee  eddf0a26          VLDR     s1,|L9.392|
0000f2  eeb40ae0          VCMPE.F32 s0,s1
0000f6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000fa  d204              BCS      |L9.262|
0000fc  f44f6096          MOV      r0,#0x4b0
000100  f04f4180          MOV      r1,#0x40000000
000104  6388              STR      r0,[r1,#0x38]
                  |L9.262|
;;;206    	if(PWM3>_FLY_MAX_OUT)	PWM3=_FLY_MAX_OUT;
000106  f04f4080          MOV      r0,#0x40000000
00010a  6bc0              LDR      r0,[r0,#0x3c]
00010c  f24051aa          MOV      r1,#0x5aa
000110  4288              CMP      r0,r1
000112  d902              BLS      |L9.282|
000114  4608              MOV      r0,r1
000116  0741              LSLS     r1,r0,#29
000118  63c8              STR      r0,[r1,#0x3c]
                  |L9.282|
;;;207    	if(PWM3<1200.0f)					PWM3=1200.0f;
00011a  f04f4080          MOV      r0,#0x40000000
00011e  6bc0              LDR      r0,[r0,#0x3c]
000120  ee000a10          VMOV     s0,r0
000124  eeb80a40          VCVT.F32.U32 s0,s0
000128  eddf0a17          VLDR     s1,|L9.392|
00012c  eeb40ae0          VCMPE.F32 s0,s1
000130  eef1fa10          VMRS     APSR_nzcv,FPSCR
000134  d204              BCS      |L9.320|
000136  f44f6096          MOV      r0,#0x4b0
00013a  f04f4180          MOV      r1,#0x40000000
00013e  63c8              STR      r0,[r1,#0x3c]
                  |L9.320|
;;;208    	if(PWM4>_FLY_MAX_OUT)	PWM4=_FLY_MAX_OUT;
000140  f04f4080          MOV      r0,#0x40000000
000144  6c00              LDR      r0,[r0,#0x40]
000146  f24051aa          MOV      r1,#0x5aa
00014a  4288              CMP      r0,r1
00014c  d902              BLS      |L9.340|
00014e  4608              MOV      r0,r1
000150  0741              LSLS     r1,r0,#29
000152  6408              STR      r0,[r1,#0x40]
                  |L9.340|
;;;209    	if(PWM4<1200.0f)					PWM4=1200.0f;
000154  f04f4080          MOV      r0,#0x40000000
000158  6c00              LDR      r0,[r0,#0x40]
00015a  ee000a10          VMOV     s0,r0
00015e  eeb80a40          VCVT.F32.U32 s0,s0
000162  eddf0a09          VLDR     s1,|L9.392|
000166  eeb40ae0          VCMPE.F32 s0,s1
00016a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00016e  d204              BCS      |L9.378|
000170  f44f6096          MOV      r0,#0x4b0
000174  f04f4180          MOV      r1,#0x40000000
000178  6408              STR      r0,[r1,#0x40]
                  |L9.378|
;;;210    	
;;;211    //	u1_printf("PWM1:%d\tPWM2:%d\tPWM3:%d\tPWM4:%d\t\r\n",PWM1,PWM2,PWM3,PWM4);
;;;212    
;;;213    }
00017a  b007              ADD      sp,sp,#0x1c
00017c  bd30              POP      {r4,r5,pc}
;;;214    
                          ENDP

00017e  0000              DCW      0x0000
                  |L9.384|
000180  425c0000          DCFS     0x425c0000 ; 55
                  |L9.388|
000184  44a28000          DCFS     0x44a28000 ; 1300
                  |L9.392|
000188  44960000          DCFS     0x44960000 ; 1200

                          AREA ||i.Motor_PwrAdd||, CODE, READONLY, ALIGN=2

                  Motor_PwrAdd PROC
;;;176    
;;;177    void Motor_PwrAdd(float throttle,float controlout[],float motorout[],float addout)
000000  ed901a00          VLDR     s2,[r0,#0]
;;;178    {
;;;179    		motorout[0]=throttle-  controlout[0]+0*controlout[1]-controlout[2];
000004  ee301a41          VSUB.F32 s2,s0,s2
000008  edd01a01          VLDR     s3,[r0,#4]
00000c  ed9f2a23          VLDR     s4,|L10.156|
000010  ee021a21          VMLA.F32 s2,s4,s3
000014  edd01a02          VLDR     s3,[r0,#8]
000018  ee311a61          VSUB.F32 s2,s2,s3
00001c  ed811a00          VSTR     s2,[r1,#0]
;;;180    		motorout[1]=throttle+0*controlout[0]+  controlout[1]+controlout[2];
000020  edd01a00          VLDR     s3,[r0,#0]
000024  ed9f2a1d          VLDR     s4,|L10.156|
000028  eeb01a40          VMOV.F32 s2,s0
00002c  ee021a21          VMLA.F32 s2,s4,s3
000030  edd01a01          VLDR     s3,[r0,#4]
000034  ee311a21          VADD.F32 s2,s2,s3
000038  edd01a02          VLDR     s3,[r0,#8]
00003c  ee311a21          VADD.F32 s2,s2,s3
000040  ed811a01          VSTR     s2,[r1,#4]
;;;181    		motorout[2]=throttle+ controlout[0]-0*controlout[1]-controlout[2];
000044  ed901a00          VLDR     s2,[r0,#0]
000048  ee311a00          VADD.F32 s2,s2,s0
00004c  edd01a01          VLDR     s3,[r0,#4]
000050  ed9f2a12          VLDR     s4,|L10.156|
000054  ee021a61          VMLS.F32 s2,s4,s3
000058  edd01a02          VLDR     s3,[r0,#8]
00005c  ee311a61          VSUB.F32 s2,s2,s3
000060  ed811a02          VSTR     s2,[r1,#8]
;;;182    		motorout[3]=throttle-0*controlout[0]-  controlout[1]+controlout[2];
000064  edd01a00          VLDR     s3,[r0,#0]
000068  ed9f2a0c          VLDR     s4,|L10.156|
00006c  eeb01a40          VMOV.F32 s2,s0
000070  ee021a61          VMLS.F32 s2,s4,s3
000074  edd01a01          VLDR     s3,[r0,#4]
000078  ee311a61          VSUB.F32 s2,s2,s3
00007c  edd01a02          VLDR     s3,[r0,#8]
000080  ee311a21          VADD.F32 s2,s2,s3
000084  ed811a03          VSTR     s2,[r1,#0xc]
;;;183    		motorout[4]=0.0f;
000088  ed9f1a04          VLDR     s2,|L10.156|
00008c  ed811a04          VSTR     s2,[r1,#0x10]
;;;184    		motorout[5]=0.0f;
000090  ed9f1a02          VLDR     s2,|L10.156|
000094  ed811a05          VSTR     s2,[r1,#0x14]
;;;185    //		u1_printf("%7.3f\t%7.3f\t%7.3f\t%7.3f\t\r\n",motorout[3],motorout[2],motorout[1],motorout[0]);
;;;186    }
000098  4770              BX       lr
;;;187    
                          ENDP

00009a  0000              DCW      0x0000
                  |L10.156|
00009c  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.Motor_PwrAdd_Control||, CODE, READONLY, ALIGN=2

                  Motor_PwrAdd_Control PROC
;;;229    
;;;230    void Motor_PwrAdd_Control(float DR16_Control,float addout)
000000  b500              PUSH     {lr}
;;;231    {
000002  eef02a40          VMOV.F32 s5,s0
000006  eeb03a60          VMOV.F32 s6,s1
;;;232    		Motor_PwrAdd(DR16_Control,ControlOut,MotorOut,addout);	
00000a  eef00a43          VMOV.F32 s1,s6
00000e  4903              LDR      r1,|L11.28|
000010  4803              LDR      r0,|L11.32|
000012  eeb00a62          VMOV.F32 s0,s5
000016  f7fffffe          BL       Motor_PwrAdd
;;;233    }
00001a  bd00              POP      {pc}
                          ENDP

                  |L11.28|
                          DCD      MotorOut
                  |L11.32|
                          DCD      ControlOut

                          AREA ||i.X_Axic||, CODE, READONLY, ALIGN=1

                  X_Axic PROC
;;;36     
;;;37     void X_Axic(int *MotorData,int power)
000000  b530              PUSH     {r4,r5,lr}
;;;38     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;39         Motor(MotorData,Motor1,-power);
000006  4262              RSBS     r2,r4,#0
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Motor
;;;40         Motor(MotorData,Motor2,-power);
000010  4262              RSBS     r2,r4,#0
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Motor
;;;41         Motor(MotorData,Motor3,power);
00001a  4622              MOV      r2,r4
00001c  2102              MOVS     r1,#2
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       Motor
;;;42         Motor(MotorData,Motor4,power);
000024  4622              MOV      r2,r4
000026  2103              MOVS     r1,#3
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Motor
;;;43     }
00002e  bd30              POP      {r4,r5,pc}
;;;44     
                          ENDP


                          AREA ||i.Y_Axic||, CODE, READONLY, ALIGN=1

                  Y_Axic PROC
;;;44     
;;;45     void Y_Axic(int *MotorData,int power)
000000  b530              PUSH     {r4,r5,lr}
;;;46     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;47         Motor(MotorData,Motor1,-power);
000006  4262              RSBS     r2,r4,#0
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Motor
;;;48         Motor(MotorData,Motor2,power);
000010  4622              MOV      r2,r4
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Motor
;;;49         Motor(MotorData,Motor3,power);
00001a  4622              MOV      r2,r4
00001c  2102              MOVS     r1,#2
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       Motor
;;;50         Motor(MotorData,Motor4,-power);
000024  4262              RSBS     r2,r4,#0
000026  2103              MOVS     r1,#3
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Motor
;;;51     }
00002e  bd30              POP      {r4,r5,pc}
;;;52     
                          ENDP


                          AREA ||i.Z_Axic||, CODE, READONLY, ALIGN=1

                  Z_Axic PROC
;;;52     
;;;53     void  Z_Axic(int *MotorData,int power)
000000  b530              PUSH     {r4,r5,lr}
;;;54     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;55     
;;;56     	Motor(MotorData,Motor1,-power);
000006  4262              RSBS     r2,r4,#0
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       Motor
;;;57         Motor(MotorData,Motor2,-power);
000010  4262              RSBS     r2,r4,#0
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Motor
;;;58         Motor(MotorData,Motor3,-power);
00001a  4262              RSBS     r2,r4,#0
00001c  2102              MOVS     r1,#2
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       Motor
;;;59         Motor(MotorData,Motor4,-power);
000024  4262              RSBS     r2,r4,#0
000026  2103              MOVS     r1,#3
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       Motor
;;;60     }
00002e  bd30              POP      {r4,r5,pc}
;;;61     void Motor_DataScale(int *MotorData,int max)
                          ENDP


                          AREA ||i.controlnormalmode_update||, CODE, READONLY, ALIGN=2

                  controlnormalmode_update PROC
;;;218    extern int pwm_flag;
;;;219    void controlnormalmode_update(float dt)
000000  b510              PUSH     {r4,lr}
;;;220    {
000002  ed2d8b02          VPUSH    {d8}
000006  eeb08a40          VMOV.F32 s16,s0
;;;221    		if(pwm_flag)
00000a  480c              LDR      r0,|L15.60|
00000c  6800              LDR      r0,[r0,#0]  ; pwm_flag
00000e  b190              CBZ      r0,|L15.54|
;;;222    		{
;;;223    	  Pidcontrol_Altitude_VEL(&Target,&Eulla,&velocity,ControlOut,dt);
000010  eeb00a48          VMOV.F32 s0,s16
000014  4b0a              LDR      r3,|L15.64|
000016  4a0b              LDR      r2,|L15.68|
000018  490b              LDR      r1,|L15.72|
00001a  480c              LDR      r0,|L15.76|
00001c  f7fffffe          BL       _Z23Pidcontrol_Altitude_VELP6TARGETP5EULLAP11Data_To_ImuPff ; Pidcontrol_Altitude_VEL(TARGET*, EULLA*, Data_To_Imu*, float*, float)
;;;224    		extern float RC_control;
;;;225    		Motor_PwrAdd_Control(RC_control,addout);
000020  480b              LDR      r0,|L15.80|
000022  edd00a00          VLDR     s1,[r0,#0]
000026  480b              LDR      r0,|L15.84|
000028  ed900a00          VLDR     s0,[r0,#0]
00002c  f7fffffe          BL       Motor_PwrAdd_Control
;;;226    		Motor_PwmValSet(MotorOut);
000030  4809              LDR      r0,|L15.88|
000032  f7fffffe          BL       Motor_PwmValSet
                  |L15.54|
;;;227    		}
;;;228    }
000036  ecbd8b02          VPOP     {d8}
00003a  bd10              POP      {r4,pc}
;;;229    
                          ENDP

                  |L15.60|
                          DCD      pwm_flag
                  |L15.64|
                          DCD      ControlOut
                  |L15.68|
                          DCD      velocity
                  |L15.72|
                          DCD      Eulla
                  |L15.76|
                          DCD      Target
                  |L15.80|
                          DCD      addout
                  |L15.84|
                          DCD      RC_control
                  |L15.88|
                          DCD      MotorOut

                          AREA ||.ARM.exidx||, LINKORDER=||i.Motor_CarFrame||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i.Motor_CarFrame||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i.Motor_DataScale||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_DataScale||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i.Motor||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i.Z_Axic||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Z_Axic||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i.Y_Axic||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Y_Axic||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i.X_Axic||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.X_Axic||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i.Motor_Aguest||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_Aguest||
                          DCD      0x00000001

                          AREA ||area_number.23||, LINKORDER=||i.Motor_Power||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.23||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_Power||
                          DCD      0x00000001

                          AREA ||area_number.24||, LINKORDER=||i.Motor_Other||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_Other||
                          DCD      0x00000001

                          AREA ||area_number.25||, LINKORDER=||i.Motor_GetMassage||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.25||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_GetMassage||
                          DCD      0x00000001

                          AREA ||area_number.26||, LINKORDER=||i.MOTOR_SetPWM||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.26||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.MOTOR_SetPWM||
                          DCD      0x00000001

                          AREA ||area_number.27||, LINKORDER=||i.Motor_PwrAdd||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.27||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_PwrAdd||
                          DCD      0x00000001

                          AREA ||area_number.28||, LINKORDER=||i.Motor_PwmValSet||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.28||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_PwmValSet||
                          DCD      0x00000001

                          AREA ||area_number.29||, LINKORDER=||i.Motor_PwrAdd_Control||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.29||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.Motor_PwrAdd_Control||
                          DCD      0x00000001

                          AREA ||area_number.30||, LINKORDER=||i.controlnormalmode_update||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.30||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i.controlnormalmode_update||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ControlOut
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000110
                          DCD      0x00000110
000008  00000800          DCB      0x00,0x00,0x08,0x00
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
00001c  00000800          DCB      0x00,0x00,0x08,0x00
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000002
                          DCD      0x00000002
000030  00000800          DCB      0x00,0x00,0x08,0x00
000034  00000000          DCB      0x00,0x00,0x00,0x00
000038  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000130
                          DCD      0x00000130
000044  00000800          DCB      0x00,0x00,0x08,0x00
000048  00000000          DCB      0x00,0x00,0x00,0x00
00004c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
000058  00000855          DCB      0x00,0x00,0x08,0x55
00005c  55555555          DCB      0x55,0x55,0x55,0x55
000060  55555500          DCB      0x55,0x55,0x55,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  MotorOut
000000  3f000000          DCFS     0x3f000000 ; 0.5
000004  3f000000          DCFS     0x3f000000 ; 0.5
000008  3f000000          DCFS     0x3f000000 ; 0.5
00000c  3f000000          DCFS     0x3f000000 ; 0.5
                          %        8

                          AREA ||t._Z11bubble_sortIiEvPT_i||, COMGROUP=_Z11bubble_sortIiEvPT_i, CODE, READONLY, ALIGN=1

                  _Z11bubble_sortIiEvPT_i PROC ; void bubble_sort<int>(T1*, int)
;;;30     template<class T>
;;;31     void bubble_sort(T a[], int n)
000000  b570              PUSH     {r4-r6,lr}
;;;32     {
000002  4602              MOV      r2,r0
;;;33         int i,j;
;;;34     //	char flag;
;;;35     	T temp;
;;;36         for (j = 0; j < n - 1; j++)
000004  2300              MOVS     r3,#0
000006  e018              B        |L117.58|
                  |L117.8|
;;;37     	{
;;;38     //		if(flag)
;;;39     //			break;
;;;40     //		flag = 1;
;;;41             for (i = 0; i < n - 1 - j; i++)
000008  2000              MOVS     r0,#0
00000a  e011              B        |L117.48|
                  |L117.12|
;;;42             {
;;;43                 if(a[i] > a[i + 1])
00000c  f8526020          LDR      r6,[r2,r0,LSL #2]
000010  1c45              ADDS     r5,r0,#1
000012  f8525025          LDR      r5,[r2,r5,LSL #2]
000016  42ae              CMP      r6,r5
000018  dd09              BLE      |L117.46|
;;;44                 {
;;;45                     temp = a[i];
00001a  f8524020          LDR      r4,[r2,r0,LSL #2]
;;;46                     a[i] = a[i + 1];
00001e  1c45              ADDS     r5,r0,#1
000020  f8525025          LDR      r5,[r2,r5,LSL #2]
000024  f8425020          STR      r5,[r2,r0,LSL #2]
;;;47                     a[i + 1] = temp;
000028  1c45              ADDS     r5,r0,#1
00002a  f8424025          STR      r4,[r2,r5,LSL #2]
                  |L117.46|
00002e  1c40              ADDS     r0,r0,#1              ;41
                  |L117.48|
000030  1e4d              SUBS     r5,r1,#1              ;41
000032  1aed              SUBS     r5,r5,r3              ;41
000034  4285              CMP      r5,r0                 ;41
000036  dce9              BGT      |L117.12|
000038  1c5b              ADDS     r3,r3,#1              ;36
                  |L117.58|
00003a  1e4d              SUBS     r5,r1,#1              ;36
00003c  429d              CMP      r5,r3                 ;36
00003e  dce3              BGT      |L117.8|
;;;48     //				flag = 0;
;;;49                 }
;;;50             }
;;;51     	}
;;;52     }
000040  bd70              POP      {r4-r6,pc}
;;;53     //#ifdef __cplusplus
                          ENDP


                          AREA ||area_number.118||, COMGROUP=_Z11bubble_sortIiEvPT_i, LINKORDER=||t._Z11bubble_sortIiEvPT_i||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.118||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||t._Z11bubble_sortIiEvPT_i||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\motor.cpp"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_motor_cpp_ff34c24a___Z7__REV16j|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_motor_cpp_ff34c24a___Z7__REV16j| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_motor_cpp_ff34c24a___Z7__REVSHi|
#line 144
|__asm___9_motor_cpp_ff34c24a___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_motor_cpp_ff34c24a___Z5__RRXj|
#line 300
|__asm___9_motor_cpp_ff34c24a___Z5__RRXj| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
