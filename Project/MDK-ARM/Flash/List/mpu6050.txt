; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\mpu6050.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mpu6050.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\MySrc -I..\..\Libraries -I..\..\MySrc\ostask -I..\..\MySrc\MPU6050 -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_CM4 --omf_browse=.\flash\obj\mpu6050.crf ..\..\MySrc\MPU6050\mpu6050.c]
                          THUMB

                          AREA ||i.AHRS_Update||, CODE, READONLY, ALIGN=2

                  AHRS_Update PROC
;;;769    /**************************/
;;;770    void AHRS_Update(float dt)
000000  b510              PUSH     {r4,lr}
;;;771    {
000002  ed2d8b02          VPUSH    {d8}
000006  eeb08a40          VMOV.F32 s16,s0
;;;772    	imu_update(&VELOCITY,&ACC,&Eulla,dt);//姿态解算
00000a  eeb00a48          VMOV.F32 s0,s16
00000e  4a09              LDR      r2,|L1.52|
000010  4909              LDR      r1,|L1.56|
000012  480a              LDR      r0,|L1.60|
000014  f7fffffe          BL       imu_update
;;;773    	
;;;774    	AcczWithoutG_Get(q,ACC);
000018  4807              LDR      r0,|L1.56|
00001a  ed901a02          VLDR     s2,[r0,#8]
00001e  edd00a01          VLDR     s1,[r0,#4]
000022  ed900a00          VLDR     s0,[r0,#0]
000026  4806              LDR      r0,|L1.64|
000028  f7fffffe          BL       AcczWithoutG_Get
;;;775    	
;;;776    }
00002c  ecbd8b02          VPOP     {d8}
000030  bd10              POP      {r4,pc}
;;;777    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      Eulla
                  |L1.56|
                          DCD      ACC
                  |L1.60|
                          DCD      VELOCITY
                  |L1.64|
                          DCD      q

                          AREA ||i.AcczWithoutG_Get||, CODE, READONLY, ALIGN=2

                  AcczWithoutG_Get PROC
;;;754    //返回值：除去重力加速度的加速度大小
;;;755    float AcczWithoutG_Get(float q[],Data_To_Imu acc)
000000  b501              PUSH     {r0,lr}
;;;756    {
000002  ed2d0b04          VPUSH    {d0-d1}
;;;757    	float w=q[0],x=q[1],y=q[2],z=q[3];
000006  ed904a00          VLDR     s8,[r0,#0]
00000a  eeb02a44          VMOV.F32 s4,s8
00000e  ed904a01          VLDR     s8,[r0,#4]
000012  eef00a44          VMOV.F32 s1,s8
000016  ed904a02          VLDR     s8,[r0,#8]
00001a  eeb01a44          VMOV.F32 s2,s8
00001e  ed904a03          VLDR     s8,[r0,#0xc]
000022  eef01a44          VMOV.F32 s3,s8
;;;758    	float ax=0.0f,ay=0.0f,az=0.0f;
000026  ed9f4a21          VLDR     s8,|L2.172|
00002a  eef02a44          VMOV.F32 s5,s8
00002e  ed9f4a1f          VLDR     s8,|L2.172|
000032  eeb03a44          VMOV.F32 s6,s8
000036  ed9f4a1d          VLDR     s8,|L2.172|
00003a  eef03a44          VMOV.F32 s7,s8
;;;759    	float accwithoutg=0.0f;
00003e  ed9f4a1b          VLDR     s8,|L2.172|
000042  eeb00a44          VMOV.F32 s0,s8
;;;760    	ax=2*(w*y-x*z);
000046  ee224a01          VMUL.F32 s8,s4,s2
00004a  ee004ae1          VMLS.F32 s8,s1,s3
00004e  eef04a00          VMOV.F32 s9,#2.00000000
000052  ee244a24          VMUL.F32 s8,s8,s9
000056  eef02a44          VMOV.F32 s5,s8
;;;761    	ay=2*(w*x+y*z);
00005a  ee224a20          VMUL.F32 s8,s4,s1
00005e  ee014a21          VMLA.F32 s8,s2,s3
000062  eef04a00          VMOV.F32 s9,#2.00000000
000066  ee244a24          VMUL.F32 s8,s8,s9
00006a  eeb03a44          VMOV.F32 s6,s8
;;;762    	az=w*w-x*x-y*y+z*z;
00006e  ee224a02          VMUL.F32 s8,s4,s4
000072  ee004ae0          VMLS.F32 s8,s1,s1
000076  ee014a41          VMLS.F32 s8,s2,s2
00007a  ee014aa1          VMLA.F32 s8,s3,s3
00007e  eef03a44          VMOV.F32 s7,s8
;;;763    	
;;;764    	accwithoutg=ax*acc.X+ay*acc.Y+az*acc.Z-9.8f;
000082  ed9d4a00          VLDR     s8,[sp,#0]
000086  ee244a22          VMUL.F32 s8,s8,s5
00008a  eddd4a01          VLDR     s9,[sp,#4]
00008e  ee034a24          VMLA.F32 s8,s6,s9
000092  eddd4a02          VLDR     s9,[sp,#8]
000096  ee034aa4          VMLA.F32 s8,s7,s9
00009a  eddf4a05          VLDR     s9,|L2.176|
00009e  ee344a64          VSUB.F32 s8,s8,s9
0000a2  eeb00a44          VMOV.F32 s0,s8
;;;765    //	u1_printf("%7.3f\r\n",accwithoutg);
;;;766    	
;;;767    	return accwithoutg;
;;;768    }
0000a6  b005              ADD      sp,sp,#0x14
0000a8  bd00              POP      {pc}
;;;769    /**************************/
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
0000ac  00000000          DCFS     0x00000000 ; 0
                  |L2.176|
0000b0  411ccccd          DCFS     0x411ccccd ; 9.8000001907348633

                          AREA ||i.Imu_data_Prepare||, CODE, READONLY, ALIGN=2

                  Imu_data_Prepare PROC
;;;778    
;;;779    void Imu_data_Prepare(void)
000000  b510              PUSH     {r4,lr}
;;;780    {
;;;781    				#if USE_KALMAN
;;;782    			{
;;;783    				MPU6050_Data_Read_Analys_Kalman(&velocity,&acc);//kalman加窗口滑动滤波
;;;784    				
;;;785    			}
;;;786    			#else
;;;787    			{
;;;788    //				MPU6050_Data_Read_Analys_LPF(&velocity,&acc);//一阶低通加窗口滑动	
;;;789    				MPU6050_Data_Read_Analys(&velocity,&acc);		
000002  4905              LDR      r1,|L3.24|
000004  4805              LDR      r0,|L3.28|
000006  f7fffffe          BL       MPU6050_Data_Read_Analys
;;;790    				
;;;791    				
;;;792    			}
;;;793    			#endif
;;;794    			
;;;795    			MPU6050_Data_Exchage(&acc,&velocity,&ACC,&VELOCITY);
00000a  4b05              LDR      r3,|L3.32|
00000c  4a05              LDR      r2,|L3.36|
00000e  4903              LDR      r1,|L3.28|
000010  4801              LDR      r0,|L3.24|
000012  f7fffffe          BL       MPU6050_Data_Exchage
;;;796    //			u1_printf("%7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\r\n", ACC.Y, ACC.X, ACC.Z, VELOCITY.X, VELOCITY.Y, VELOCITY.Z);
;;;797    }
000016  bd10              POP      {r4,pc}
;;;798    
                          ENDP

                  |L3.24|
                          DCD      acc
                  |L3.28|
                          DCD      velocity
                  |L3.32|
                          DCD      VELOCITY
                  |L3.36|
                          DCD      ACC

                          AREA ||i.Invsqrt||, CODE, READONLY, ALIGN=2

                  Invsqrt PROC
;;;33     *******************************************************************************/
;;;34     float Invsqrt(float x)
000000  eef00a40          VMOV.F32 s1,s0
;;;35     {
;;;36     	float halfx = 0.5f * x;
000004  eef61a00          VMOV.F32 s3,#0.50000000
000008  ee601aa1          VMUL.F32 s3,s1,s3
00000c  eeb01a61          VMOV.F32 s2,s3
;;;37     	float y = x;
000010  eeb00a60          VMOV.F32 s0,s1
;;;38     	long i = *(long*)&y;
000014  ee100a10          VMOV     r0,s0
;;;39     	i = 0x5f3759df - (i>>1);
000018  4907              LDR      r1,|L4.56|
00001a  eba10060          SUB      r0,r1,r0,ASR #1
;;;40     	y = *(float*)&i;
00001e  ee000a10          VMOV     s0,r0
;;;41     	y = y * (1.5f - (halfx * y * y));
000022  ee212a00          VMUL.F32 s4,s2,s0
000026  eef71a08          VMOV.F32 s3,#1.50000000
00002a  ee421a40          VMLS.F32 s3,s4,s0
00002e  ee611a80          VMUL.F32 s3,s3,s0
000032  eeb00a61          VMOV.F32 s0,s3
;;;42     	return y;
;;;43     }
000036  4770              BX       lr
;;;44     
                          ENDP

                  |L4.56|
                          DCD      0x5f3759df

                          AREA ||i.MPU6050_Data_Check_||, CODE, READONLY, ALIGN=2

                  MPU6050_Data_Check_ PROC
;;;439    
;;;440    void MPU6050_Data_Check_(OFFSET *offset)
000000  b530              PUSH     {r4,r5,lr}
;;;441    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;442    	u8 num=0;
000006  2500              MOVS     r5,#0
;;;443    	int32_t temp[6]={0};
000008  2118              MOVS     r1,#0x18
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;444    //	LED1_ON();//
;;;445    	for(num=0;num<offsetlength;num++)
000010  bf00              NOP      
000012  e02d              B        |L5.112|
                  |L5.20|
;;;446    	{
;;;447    	     MPU6050_Read_To_Calculate(&Sensor_Acc,&Sensor_Gyro);	
000014  492b              LDR      r1,|L5.196|
000016  482c              LDR      r0,|L5.200|
000018  f7fffffe          BL       MPU6050_Read_To_Calculate
;;;448    		
;;;449    	   temp[0]+=Sensor_Acc.X;
00001c  492a              LDR      r1,|L5.200|
00001e  f9b11000          LDRSH    r1,[r1,#0]  ; Sensor_Acc
000022  9801              LDR      r0,[sp,#4]
000024  4408              ADD      r0,r0,r1
000026  9001              STR      r0,[sp,#4]
;;;450    		 temp[1]+=Sensor_Acc.Y;
000028  4927              LDR      r1,|L5.200|
00002a  f9b11002          LDRSH    r1,[r1,#2]  ; Sensor_Acc
00002e  9802              LDR      r0,[sp,#8]
000030  4408              ADD      r0,r0,r1
000032  9002              STR      r0,[sp,#8]
;;;451    		 temp[2]+=Sensor_Acc.Z;
000034  4924              LDR      r1,|L5.200|
000036  f9b11004          LDRSH    r1,[r1,#4]  ; Sensor_Acc
00003a  9803              LDR      r0,[sp,#0xc]
00003c  4408              ADD      r0,r0,r1
00003e  9003              STR      r0,[sp,#0xc]
;;;452    		
;;;453    		 temp[3]+=Sensor_Gyro.X;
000040  4920              LDR      r1,|L5.196|
000042  f9b11000          LDRSH    r1,[r1,#0]  ; Sensor_Gyro
000046  9804              LDR      r0,[sp,#0x10]
000048  4408              ADD      r0,r0,r1
00004a  9004              STR      r0,[sp,#0x10]
;;;454    		 temp[4]+=Sensor_Gyro.Y;
00004c  491d              LDR      r1,|L5.196|
00004e  f9b11002          LDRSH    r1,[r1,#2]  ; Sensor_Gyro
000052  9805              LDR      r0,[sp,#0x14]
000054  4408              ADD      r0,r0,r1
000056  9005              STR      r0,[sp,#0x14]
;;;455    		 temp[5]+=Sensor_Gyro.Z;
000058  491a              LDR      r1,|L5.196|
00005a  f9b11004          LDRSH    r1,[r1,#4]  ; Sensor_Gyro
00005e  9806              LDR      r0,[sp,#0x18]
000060  4408              ADD      r0,r0,r1
000062  9006              STR      r0,[sp,#0x18]
;;;456    		 delay_ms(5);
000064  2005              MOVS     r0,#5
000066  f8dfc064          LDR      r12,|L5.204|
00006a  df00              SVC      #0x0
00006c  1c68              ADDS     r0,r5,#1              ;445
00006e  b2c5              UXTB     r5,r0                 ;445
                  |L5.112|
000070  2d64              CMP      r5,#0x64              ;445
000072  dbcf              BLT      |L5.20|
;;;457    	}
;;;458    	
;;;459    	offset->AX_Offset=temp[0]/offsetlength;
000074  2164              MOVS     r1,#0x64
000076  9801              LDR      r0,[sp,#4]
000078  fb90f0f1          SDIV     r0,r0,r1
00007c  b200              SXTH     r0,r0
00007e  8020              STRH     r0,[r4,#0]
;;;460    	offset->AY_Offset=temp[1]/offsetlength;
000080  9802              LDR      r0,[sp,#8]
000082  fb90f0f1          SDIV     r0,r0,r1
000086  b200              SXTH     r0,r0
000088  8060              STRH     r0,[r4,#2]
;;;461    	offset->AZ_Offset=ACC_8G_SCALE-temp[2]/offsetlength;
00008a  9803              LDR      r0,[sp,#0xc]
00008c  fb90f0f1          SDIV     r0,r0,r1
000090  f5c05080          RSB      r0,r0,#0x1000
000094  b200              SXTH     r0,r0
000096  80a0              STRH     r0,[r4,#4]
;;;462    	
;;;463    	offset->GX_Offset=temp[3]/offsetlength;
000098  9804              LDR      r0,[sp,#0x10]
00009a  fb90f0f1          SDIV     r0,r0,r1
00009e  b200              SXTH     r0,r0
0000a0  80e0              STRH     r0,[r4,#6]
;;;464    	offset->GY_Offset=temp[4]/offsetlength;
0000a2  9805              LDR      r0,[sp,#0x14]
0000a4  fb90f0f1          SDIV     r0,r0,r1
0000a8  b200              SXTH     r0,r0
0000aa  8120              STRH     r0,[r4,#8]
;;;465    	offset->GZ_Offset=temp[5]/offsetlength;
0000ac  9806              LDR      r0,[sp,#0x18]
0000ae  fb90f0f1          SDIV     r0,r0,r1
0000b2  b200              SXTH     r0,r0
0000b4  8160              STRH     r0,[r4,#0xa]
;;;466    // 	STMFLASH_Write(Read_Addr,(u16*)off_set,6);//数据保存
;;;467    	delay_ms(20);
0000b6  2014              MOVS     r0,#0x14
0000b8  f8dfc010          LDR      r12,|L5.204|
0000bc  df00              SVC      #0x0
;;;468    //	LED1_OFF();
;;;469    //	printf("offset:%d\t %d\t %d\t %d\t %d\t %d\r\n",off_set[0],off_set[1],off_set[2],off_set[3],off_set[4],off_set[5]);
;;;470    	
;;;471    }
0000be  b007              ADD      sp,sp,#0x1c
0000c0  bd30              POP      {r4,r5,pc}
;;;472    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L5.196|
                          DCD      Sensor_Gyro
                  |L5.200|
                          DCD      Sensor_Acc
                  |L5.204|
                          DCD      rt_dly_wait

                          AREA ||i.MPU6050_Data_Exchage||, CODE, READONLY, ALIGN=1

                  MPU6050_Data_Exchage PROC
;;;602    //陀螺仪测得的角速度数据在imuupdate函数里面会改变值，如果采用地址传递改变参数值的话
;;;603    void MPU6050_Data_Exchage(Data_To_Imu*accin,Data_To_Imu*gyroin,Data_To_Imu*accout,Data_To_Imu*gyroout)
000000  ed900a00          VLDR     s0,[r0,#0]
;;;604    {
;;;605    	accout->X=accin->X;
000004  ed820a00          VSTR     s0,[r2,#0]
;;;606    	accout->Y=accin->Y;
000008  ed900a01          VLDR     s0,[r0,#4]
00000c  ed820a01          VSTR     s0,[r2,#4]
;;;607    	accout->Z=accin->Z;
000010  ed900a02          VLDR     s0,[r0,#8]
000014  ed820a02          VSTR     s0,[r2,#8]
;;;608    
;;;609    	gyroout->X=gyroin->X;
000018  ed910a00          VLDR     s0,[r1,#0]
00001c  ed830a00          VSTR     s0,[r3,#0]
;;;610    	gyroout->Y=gyroin->Y;
000020  ed910a01          VLDR     s0,[r1,#4]
000024  ed830a01          VSTR     s0,[r3,#4]
;;;611    	gyroout->Z=gyroin->Z;
000028  ed910a02          VLDR     s0,[r1,#8]
00002c  ed830a02          VSTR     s0,[r3,#8]
;;;612    //	u1_printf("%7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\r\n", accout->X, accout->Y, accout->Z, gyroout->X, gyroout->Y, gyroout->Z);
;;;613    }
000030  4770              BX       lr
;;;614    
                          ENDP


                          AREA ||i.MPU6050_Data_Read_Analys||, CODE, READONLY, ALIGN=2

                  MPU6050_Data_Read_Analys PROC
;;;544    //滤波深度不宜过大，否则加大数据延时，降低动态效应
;;;545    void MPU6050_Data_Read_Analys(Data_To_Imu *GYRO,Data_To_Imu *Acc)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;546    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;547    	u8 i=0,j=0;
000008  2400              MOVS     r4,#0
00000a  2500              MOVS     r5,#0
;;;548    	static u8 count=0,counter=0;//计数变量
;;;549    	int32_t temp1=0,temp2=0,temp3=0,temp4=0,temp5=0,temp6=0;
00000c  46a0              MOV      r8,r4
00000e  46a1              MOV      r9,r4
000010  46a2              MOV      r10,r4
000012  46a3              MOV      r11,r4
000014  2000              MOVS     r0,#0
000016  9001              STR      r0,[sp,#4]
000018  9000              STR      r0,[sp,#0]
;;;550    	static int16_t BUF1[accfilter_Num]={0},BUF2[accfilter_Num]={0},BUF3[accfilter_Num]={0};
;;;551    	static int16_t BUF4[gyrofilter_Num]={0},BUF5[gyrofilter_Num]={0},BUF6[gyrofilter_Num]={0};
;;;552    	
;;;553         MPU6050_Read_To_Use_(&Sensor_Acc,&Sensor_Gyro,&OffSet);//读取数据，标定
00001a  4a5f              LDR      r2,|L7.408|
00001c  495f              LDR      r1,|L7.412|
00001e  4860              LDR      r0,|L7.416|
000020  f7fffffe          BL       MPU6050_Read_To_Use_
;;;554    
;;;555       BUF1[count]=Sensor_Acc.X;
000024  485e              LDR      r0,|L7.416|
000026  8800              LDRH     r0,[r0,#0]  ; Sensor_Acc
000028  495e              LDR      r1,|L7.420|
00002a  4a5f              LDR      r2,|L7.424|
00002c  7812              LDRB     r2,[r2,#0]  ; count
00002e  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;556    	 BUF2[count]=Sensor_Acc.Y;
000032  485b              LDR      r0,|L7.416|
000034  8840              LDRH     r0,[r0,#2]  ; Sensor_Acc
000036  495d              LDR      r1,|L7.428|
000038  4a5b              LDR      r2,|L7.424|
00003a  7812              LDRB     r2,[r2,#0]  ; count
00003c  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;557    	 BUF3[count]=Sensor_Acc.Z;
000040  4857              LDR      r0,|L7.416|
000042  8880              LDRH     r0,[r0,#4]  ; Sensor_Acc
000044  495a              LDR      r1,|L7.432|
000046  4a58              LDR      r2,|L7.424|
000048  7812              LDRB     r2,[r2,#0]  ; count
00004a  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;558    	
;;;559    	 BUF4[counter]=Sensor_Gyro.X;
00004e  4853              LDR      r0,|L7.412|
000050  8800              LDRH     r0,[r0,#0]  ; Sensor_Gyro
000052  4958              LDR      r1,|L7.436|
000054  4a58              LDR      r2,|L7.440|
000056  7812              LDRB     r2,[r2,#0]  ; counter
000058  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;560    	 BUF5[counter]=Sensor_Gyro.Y;
00005c  484f              LDR      r0,|L7.412|
00005e  8840              LDRH     r0,[r0,#2]  ; Sensor_Gyro
000060  4956              LDR      r1,|L7.444|
000062  4a55              LDR      r2,|L7.440|
000064  7812              LDRB     r2,[r2,#0]  ; counter
000066  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;561    	 BUF6[counter]=Sensor_Gyro.Z;
00006a  484c              LDR      r0,|L7.412|
00006c  8880              LDRH     r0,[r0,#4]  ; Sensor_Gyro
00006e  4954              LDR      r1,|L7.448|
000070  4a51              LDR      r2,|L7.440|
000072  7812              LDRB     r2,[r2,#0]  ; counter
000074  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;562    
;;;563    	for(i=0;i<accfilter_Num;i++)
000078  bf00              NOP      
00007a  e00d              B        |L7.152|
                  |L7.124|
;;;564    	{
;;;565    		temp1+= BUF1[i];
00007c  4849              LDR      r0,|L7.420|
00007e  f9300014          LDRSH    r0,[r0,r4,LSL #1]
000082  4480              ADD      r8,r8,r0
;;;566    		temp2+= BUF2[i];
000084  4849              LDR      r0,|L7.428|
000086  f9300014          LDRSH    r0,[r0,r4,LSL #1]
00008a  4481              ADD      r9,r9,r0
;;;567    		temp3+= BUF3[i];
00008c  4848              LDR      r0,|L7.432|
00008e  f9300014          LDRSH    r0,[r0,r4,LSL #1]
000092  4482              ADD      r10,r10,r0
000094  1c60              ADDS     r0,r4,#1              ;563
000096  b2c4              UXTB     r4,r0                 ;563
                  |L7.152|
000098  2c06              CMP      r4,#6                 ;563
00009a  dbef              BLT      |L7.124|
;;;568    	}
;;;569    	
;;;570    	temp1/=accfilter_Num;
00009c  2006              MOVS     r0,#6
00009e  fb98f8f0          SDIV     r8,r8,r0
;;;571    	temp2/=accfilter_Num;
0000a2  fb99f9f0          SDIV     r9,r9,r0
;;;572    	temp3/=accfilter_Num;
0000a6  fb9afaf0          SDIV     r10,r10,r0
;;;573    	
;;;574    	for(j=0;j<gyrofilter_Num;j++)
0000aa  2500              MOVS     r5,#0
0000ac  e011              B        |L7.210|
                  |L7.174|
;;;575    	{
;;;576    		temp4+= BUF4[j];
0000ae  4841              LDR      r0,|L7.436|
0000b0  f9300015          LDRSH    r0,[r0,r5,LSL #1]
0000b4  4483              ADD      r11,r11,r0
;;;577    		temp5+= BUF5[j];
0000b6  4841              LDR      r0,|L7.444|
0000b8  f9301015          LDRSH    r1,[r0,r5,LSL #1]
0000bc  9801              LDR      r0,[sp,#4]
0000be  4408              ADD      r0,r0,r1
0000c0  9001              STR      r0,[sp,#4]
;;;578    		temp6+= BUF6[j];
0000c2  483f              LDR      r0,|L7.448|
0000c4  f9301015          LDRSH    r1,[r0,r5,LSL #1]
0000c8  9800              LDR      r0,[sp,#0]
0000ca  4408              ADD      r0,r0,r1
0000cc  9000              STR      r0,[sp,#0]
0000ce  1c68              ADDS     r0,r5,#1              ;574
0000d0  b2c5              UXTB     r5,r0                 ;574
                  |L7.210|
0000d2  2d06              CMP      r5,#6                 ;574
0000d4  dbeb              BLT      |L7.174|
;;;579    	}
;;;580    
;;;581    	temp4/=gyrofilter_Num;
0000d6  2006              MOVS     r0,#6
0000d8  fb9bfbf0          SDIV     r11,r11,r0
;;;582    	temp5/=gyrofilter_Num;
0000dc  2106              MOVS     r1,#6
0000de  9801              LDR      r0,[sp,#4]
0000e0  fb90f0f1          SDIV     r0,r0,r1
0000e4  9001              STR      r0,[sp,#4]
;;;583    	temp6/=gyrofilter_Num;
0000e6  9800              LDR      r0,[sp,#0]
0000e8  fb90f0f1          SDIV     r0,r0,r1
0000ec  9000              STR      r0,[sp,#0]
;;;584    	
;;;585    	 Acc->X=temp1/acc_denominator;//g
0000ee  ee008a10          VMOV     s0,r8
0000f2  eeb80ac0          VCVT.F32.S32 s0,s0
0000f6  eddf0a33          VLDR     s1,|L7.452|
0000fa  ee801a20          VDIV.F32 s2,s0,s1
0000fe  ed871a00          VSTR     s2,[r7,#0]
;;;586    	 Acc->Y=temp2/acc_denominator;
000102  ee009a10          VMOV     s0,r9
000106  eeb80ac0          VCVT.F32.S32 s0,s0
00010a  eddf0a2e          VLDR     s1,|L7.452|
00010e  ee801a20          VDIV.F32 s2,s0,s1
000112  ed871a01          VSTR     s2,[r7,#4]
;;;587    	 Acc->Z=temp3/acc_denominator;
000116  ee00aa10          VMOV     s0,r10
00011a  eeb80ac0          VCVT.F32.S32 s0,s0
00011e  eddf0a29          VLDR     s1,|L7.452|
000122  ee801a20          VDIV.F32 s2,s0,s1
000126  ed871a02          VSTR     s2,[r7,#8]
;;;588    		
;;;589    	 GYRO->X=temp4/gyro_denominator;//rad/s
00012a  ee00ba10          VMOV     s0,r11
00012e  eeb80ac0          VCVT.F32.S32 s0,s0
000132  eddf0a25          VLDR     s1,|L7.456|
000136  ee801a20          VDIV.F32 s2,s0,s1
00013a  ed861a00          VSTR     s2,[r6,#0]
;;;590    	 GYRO->Y=temp5/gyro_denominator;	
00013e  ed9d0a01          VLDR     s0,[sp,#4]
000142  eeb80ac0          VCVT.F32.S32 s0,s0
000146  eddf0a20          VLDR     s1,|L7.456|
00014a  ee801a20          VDIV.F32 s2,s0,s1
00014e  ed861a01          VSTR     s2,[r6,#4]
;;;591    	 GYRO->Z=temp6/gyro_denominator;
000152  ed9d0a00          VLDR     s0,[sp,#0]
000156  eeb80ac0          VCVT.F32.S32 s0,s0
00015a  eddf0a1b          VLDR     s1,|L7.456|
00015e  ee801a20          VDIV.F32 s2,s0,s1
000162  ed861a02          VSTR     s2,[r6,#8]
;;;592    		
;;;593    	count++;
000166  4810              LDR      r0,|L7.424|
000168  7800              LDRB     r0,[r0,#0]  ; count
00016a  1c40              ADDS     r0,r0,#1
00016c  490e              LDR      r1,|L7.424|
00016e  7008              STRB     r0,[r1,#0]
;;;594    	if(count==accfilter_Num) count=0;	
000170  4608              MOV      r0,r1
000172  7800              LDRB     r0,[r0,#0]  ; count
000174  2806              CMP      r0,#6
000176  d101              BNE      |L7.380|
000178  2000              MOVS     r0,#0
00017a  7008              STRB     r0,[r1,#0]
                  |L7.380|
;;;595    	counter++;
00017c  480e              LDR      r0,|L7.440|
00017e  7800              LDRB     r0,[r0,#0]  ; counter
000180  1c40              ADDS     r0,r0,#1
000182  490d              LDR      r1,|L7.440|
000184  7008              STRB     r0,[r1,#0]
;;;596    	if(counter==gyrofilter_Num) counter=0;
000186  4608              MOV      r0,r1
000188  7800              LDRB     r0,[r0,#0]  ; counter
00018a  2806              CMP      r0,#6
00018c  d101              BNE      |L7.402|
00018e  2000              MOVS     r0,#0
000190  7008              STRB     r0,[r1,#0]
                  |L7.402|
;;;597    	
;;;598    //	u1_printf("%7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\r\n", Acc->X, Acc->Y, Acc->Z, GYRO->X, GYRO->Y, GYRO->Z);
;;;599    }
000192  e8bd9ffc          POP      {r2-r12,pc}
;;;600    
                          ENDP

000196  0000              DCW      0x0000
                  |L7.408|
                          DCD      OffSet
                  |L7.412|
                          DCD      Sensor_Gyro
                  |L7.416|
                          DCD      Sensor_Acc
                  |L7.420|
                          DCD      BUF1
                  |L7.424|
                          DCD      count
                  |L7.428|
                          DCD      BUF2
                  |L7.432|
                          DCD      BUF3
                  |L7.436|
                          DCD      |symbol_number.70|
                  |L7.440|
                          DCD      |symbol_number.78|
                  |L7.444|
                          DCD      |symbol_number.71|
                  |L7.448|
                          DCD      |symbol_number.72|
                  |L7.452|
0001c4  43d0f99a          DCFS     0x43d0f99a ; 417.95001220703125
                  |L7.456|
0001c8  44eaa666          DCFS     0x44eaa666 ; 1877.199951171875

                          AREA ||i.MPU6050_Data_Read_Analys_Kalman||, CODE, READONLY, ALIGN=2

                  MPU6050_Data_Read_Analys_Kalman PROC
;;;484    kalman_struct KalmanfilterAccx,KalmanfilterAccy,KalmanfilterAccz;
;;;485    void MPU6050_Data_Read_Analys_Kalman(Data_To_Imu *GYRO,Data_To_Imu *Acc)
000000  b570              PUSH     {r4-r6,lr}
;;;486    {
000002  ed2d8b10          VPUSH    {d8-d15}
000006  b08c              SUB      sp,sp,#0x30
000008  4605              MOV      r5,r0
00000a  460c              MOV      r4,r1
;;;487    	u8 j=0;
00000c  2600              MOVS     r6,#0
;;;488    	float a=0.3f,b=0.7f;
00000e  ed9f0a89          VLDR     s0,|L8.564|
000012  eef0fa40          VMOV.F32 s31,s0
000016  ed9f0a88          VLDR     s0,|L8.568|
00001a  ed8d0a0b          VSTR     s0,[sp,#0x2c]
;;;489    	static u8 counter=0;//计数变量
;;;490    	float temp4=0,temp5=0,temp6=0;
00001e  ed9f0a87          VLDR     s0,|L8.572|
000022  eeb08a40          VMOV.F32 s16,s0
000026  ed9f0a85          VLDR     s0,|L8.572|
00002a  eef08a40          VMOV.F32 s17,s0
00002e  ed9f0a83          VLDR     s0,|L8.572|
000032  eeb0fa40          VMOV.F32 s30,s0
;;;491    	static float ACC_TEMP[3]={0};
;;;492    	static int16_t BUF4[gyrofilter_Num]={0},BUF5[gyrofilter_Num]={0},BUF6[gyrofilter_Num]={0};
;;;493    
;;;494         MPU6050_Read_To_Use_(&Sensor_Acc,&Sensor_Gyro,&OffSet);//读取数据，标定
000036  4a82              LDR      r2,|L8.576|
000038  4982              LDR      r1,|L8.580|
00003a  4883              LDR      r0,|L8.584|
00003c  f7fffffe          BL       MPU6050_Read_To_Use_
;;;495    
;;;496    /*******************卡尔曼滤波*****************************/
;;;497    	Acc->X=kalman_filter(&KalmanfilterAccx,Sensor_Acc.X);
000040  4881              LDR      r0,|L8.584|
000042  f9b00000          LDRSH    r0,[r0,#0]  ; Sensor_Acc
000046  ee000a90          VMOV     s1,r0
00004a  eef80ae0          VCVT.F32.S32 s1,s1
00004e  eeb00a60          VMOV.F32 s0,s1
000052  487e              LDR      r0,|L8.588|
000054  f7fffffe          BL       kalman_filter
000058  ed840a00          VSTR     s0,[r4,#0]
;;;498    	
;;;499    	u1_printf("%d\r\n",Acc->X);
00005c  ed940a00          VLDR     s0,[r4,#0]
000060  ee101a10          VMOV     r1,s0
000064  4608              MOV      r0,r1
000066  f7fffffe          BL       __aeabi_f2d
00006a  ec410b19          VMOV     d9,r0,r1
00006e  ec532b19          VMOV     r2,r3,d9
000072  a077              ADR      r0,|L8.592|
000074  f7fffffe          BL       u1_printf
;;;500    //	Acc->Y=kalman_filter(&KalmanfilterAccy,Sensor_Acc.Y);
;;;501    	Acc->Z=kalman_filter(&KalmanfilterAccz,Sensor_Acc.Z);
000078  4873              LDR      r0,|L8.584|
00007a  f9b00004          LDRSH    r0,[r0,#4]  ; Sensor_Acc
00007e  ee000a90          VMOV     s1,r0
000082  eef80ae0          VCVT.F32.S32 s1,s1
000086  eeb00a60          VMOV.F32 s0,s1
00008a  4873              LDR      r0,|L8.600|
00008c  f7fffffe          BL       kalman_filter
000090  ed840a02          VSTR     s0,[r4,#8]
;;;502    //	Acc->X=a*Sensor_Acc.X+b*ACC_TEMP[0];
;;;503    //	ACC_TEMP[0]=Acc->X;
;;;504    
;;;505    	Acc->Y=a*Sensor_Acc.Y+b*ACC_TEMP[1];
000094  486c              LDR      r0,|L8.584|
000096  f9b00002          LDRSH    r0,[r0,#2]  ; Sensor_Acc
00009a  ee000a10          VMOV     s0,r0
00009e  eeb80ac0          VCVT.F32.S32 s0,s0
0000a2  ee600a2f          VMUL.F32 s1,s0,s31
0000a6  486d              LDR      r0,|L8.604|
0000a8  ed901a01          VLDR     s2,[r0,#4]
0000ac  ed9d0a0b          VLDR     s0,[sp,#0x2c]
0000b0  ee400a01          VMLA.F32 s1,s0,s2
0000b4  edc40a01          VSTR     s1,[r4,#4]
;;;506    	ACC_TEMP[1]=Acc->Y;
0000b8  ed940a01          VLDR     s0,[r4,#4]
0000bc  ed800a01          VSTR     s0,[r0,#4]
;;;507    
;;;508    //	Acc->Z=a*Sensor_Acc.Z+b*ACC_TEMP[2];
;;;509    //	ACC_TEMP[2]=Acc->Z;
;;;510    
;;;511    	 BUF4[counter]=Sensor_Gyro.X;
0000c0  4860              LDR      r0,|L8.580|
0000c2  8800              LDRH     r0,[r0,#0]  ; Sensor_Gyro
0000c4  4966              LDR      r1,|L8.608|
0000c6  4a67              LDR      r2,|L8.612|
0000c8  7812              LDRB     r2,[r2,#0]  ; counter
0000ca  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;512    	 BUF5[counter]=Sensor_Gyro.Y;
0000ce  485d              LDR      r0,|L8.580|
0000d0  8840              LDRH     r0,[r0,#2]  ; Sensor_Gyro
0000d2  4965              LDR      r1,|L8.616|
0000d4  4a63              LDR      r2,|L8.612|
0000d6  7812              LDRB     r2,[r2,#0]  ; counter
0000d8  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;513    	 BUF6[counter]=Sensor_Gyro.Z;
0000dc  4859              LDR      r0,|L8.580|
0000de  8880              LDRH     r0,[r0,#4]  ; Sensor_Gyro
0000e0  4962              LDR      r1,|L8.620|
0000e2  4a60              LDR      r2,|L8.612|
0000e4  7812              LDRB     r2,[r2,#0]  ; counter
0000e6  f8210012          STRH     r0,[r1,r2,LSL #1]
;;;514    	
;;;515    	for(j=0;j<gyrofilter_Num;j++)
0000ea  bf00              NOP      
0000ec  e022              B        |L8.308|
                  |L8.238|
;;;516    	{
;;;517    		temp4+= BUF4[j];
0000ee  485c              LDR      r0,|L8.608|
0000f0  f9300016          LDRSH    r0,[r0,r6,LSL #1]
0000f4  ee000a10          VMOV     s0,r0
0000f8  eeb80ac0          VCVT.F32.S32 s0,s0
0000fc  ee300a08          VADD.F32 s0,s0,s16
000100  eeb08a40          VMOV.F32 s16,s0
;;;518    		temp5+= BUF5[j];
000104  4858              LDR      r0,|L8.616|
000106  f9300016          LDRSH    r0,[r0,r6,LSL #1]
00010a  ee000a10          VMOV     s0,r0
00010e  eeb80ac0          VCVT.F32.S32 s0,s0
000112  ee300a28          VADD.F32 s0,s0,s17
000116  eef08a40          VMOV.F32 s17,s0
;;;519    		temp6+= BUF6[j];
00011a  4854              LDR      r0,|L8.620|
00011c  f9300016          LDRSH    r0,[r0,r6,LSL #1]
000120  ee000a10          VMOV     s0,r0
000124  eeb80ac0          VCVT.F32.S32 s0,s0
000128  ee300a0f          VADD.F32 s0,s0,s30
00012c  eeb0fa40          VMOV.F32 s30,s0
000130  1c70              ADDS     r0,r6,#1              ;515
000132  b2c6              UXTB     r6,r0                 ;515
                  |L8.308|
000134  2e06              CMP      r6,#6                 ;515
000136  dbda              BLT      |L8.238|
;;;520    	}
;;;521    	
;;;522    	
;;;523    	 Acc->X/=acc_denominator;//g/m^2
000138  edd40a00          VLDR     s1,[r4,#0]
00013c  ed9f1a4c          VLDR     s2,|L8.624|
000140  ee800a81          VDIV.F32 s0,s1,s2
000144  ed840a00          VSTR     s0,[r4,#0]
;;;524    	 Acc->Y/=acc_denominator;
000148  ed940a01          VLDR     s0,[r4,#4]
00014c  eddf0a48          VLDR     s1,|L8.624|
000150  ee801a20          VDIV.F32 s2,s0,s1
000154  ed841a01          VSTR     s2,[r4,#4]
;;;525    	 Acc->Z/=acc_denominator;
000158  ed940a02          VLDR     s0,[r4,#8]
00015c  eddf0a44          VLDR     s1,|L8.624|
000160  ee801a20          VDIV.F32 s2,s0,s1
000164  ed841a02          VSTR     s2,[r4,#8]
;;;526    
;;;527    	 GYRO->X=temp4/gyroscale;//rad/s
000168  ed9f0a42          VLDR     s0,|L8.628|
00016c  eec80a00          VDIV.F32 s1,s16,s0
000170  edc50a00          VSTR     s1,[r5,#0]
;;;528    	 GYRO->Y=temp5/gyroscale;
000174  ed9f0a3f          VLDR     s0,|L8.628|
000178  eec80a80          VDIV.F32 s1,s17,s0
00017c  edc50a01          VSTR     s1,[r5,#4]
;;;529    	 GYRO->Z=temp6/gyroscale;
000180  ed9f0a3c          VLDR     s0,|L8.628|
000184  eecf0a00          VDIV.F32 s1,s30,s0
000188  edc50a02          VSTR     s1,[r5,#8]
;;;530    	 u1_printf("%7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\r\n", Acc->X, Acc->Y, Acc->Z, GYRO->X, GYRO->Y, GYRO->Z);
00018c  ed950a02          VLDR     s0,[r5,#8]
000190  ee101a10          VMOV     r1,s0
000194  4608              MOV      r0,r1
000196  f7fffffe          BL       __aeabi_f2d
00019a  ec410b19          VMOV     d9,r0,r1
00019e  ed950a01          VLDR     s0,[r5,#4]
0001a2  ee101a10          VMOV     r1,s0
0001a6  4608              MOV      r0,r1
0001a8  f7fffffe          BL       __aeabi_f2d
0001ac  ec410b1a          VMOV     d10,r0,r1
0001b0  ed950a00          VLDR     s0,[r5,#0]
0001b4  ee101a10          VMOV     r1,s0
0001b8  4608              MOV      r0,r1
0001ba  f7fffffe          BL       __aeabi_f2d
0001be  ec410b1b          VMOV     d11,r0,r1
0001c2  ed940a02          VLDR     s0,[r4,#8]
0001c6  ee101a10          VMOV     r1,s0
0001ca  4608              MOV      r0,r1
0001cc  f7fffffe          BL       __aeabi_f2d
0001d0  ec410b1c          VMOV     d12,r0,r1
0001d4  ed940a01          VLDR     s0,[r4,#4]
0001d8  ee101a10          VMOV     r1,s0
0001dc  4608              MOV      r0,r1
0001de  f7fffffe          BL       __aeabi_f2d
0001e2  ec410b1d          VMOV     d13,r0,r1
0001e6  ed940a00          VLDR     s0,[r4,#0]
0001ea  ee101a10          VMOV     r1,s0
0001ee  4608              MOV      r0,r1
0001f0  f7fffffe          BL       __aeabi_f2d
0001f4  ec410b1e          VMOV     d14,r0,r1
0001f8  ed8d9b08          VSTR     d9,[sp,#0x20]
0001fc  ed8dab06          VSTR     d10,[sp,#0x18]
000200  ed8dbb04          VSTR     d11,[sp,#0x10]
000204  ed8dcb02          VSTR     d12,[sp,#8]
000208  ed8ddb00          VSTR     d13,[sp,#0]
00020c  ec532b1e          VMOV     r2,r3,d14
000210  a019              ADR      r0,|L8.632|
000212  f7fffffe          BL       u1_printf
;;;531    	counter++;
000216  4813              LDR      r0,|L8.612|
000218  7800              LDRB     r0,[r0,#0]  ; counter
00021a  1c40              ADDS     r0,r0,#1
00021c  4911              LDR      r1,|L8.612|
00021e  7008              STRB     r0,[r1,#0]
;;;532    	if(counter==gyrofilter_Num) counter=0;
000220  4608              MOV      r0,r1
000222  7800              LDRB     r0,[r0,#0]  ; counter
000224  2806              CMP      r0,#6
000226  d101              BNE      |L8.556|
000228  2000              MOVS     r0,#0
00022a  7008              STRB     r0,[r1,#0]
                  |L8.556|
;;;533    	
;;;534    	
;;;535    }
00022c  b00c              ADD      sp,sp,#0x30
00022e  ecbd8b10          VPOP     {d8-d15}
000232  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP

                  |L8.564|
000234  3e99999a          DCFS     0x3e99999a ; 0.30000001192092896
                  |L8.568|
000238  3f333333          DCFS     0x3f333333 ; 0.69999998807907104
                  |L8.572|
00023c  00000000          DCFS     0x00000000 ; 0
                  |L8.576|
                          DCD      OffSet
                  |L8.580|
                          DCD      Sensor_Gyro
                  |L8.584|
                          DCD      Sensor_Acc
                  |L8.588|
                          DCD      KalmanfilterAccx
                  |L8.592|
000250  25640d0a          DCB      "%d\r\n",0
000254  00      
000255  00                DCB      0
000256  00                DCB      0
000257  00                DCB      0
                  |L8.600|
                          DCD      KalmanfilterAccz
                  |L8.604|
                          DCD      ACC_TEMP
                  |L8.608|
                          DCD      BUF4
                  |L8.612|
                          DCD      counter
                  |L8.616|
                          DCD      BUF5
                  |L8.620|
                          DCD      BUF6
                  |L8.624|
000270  43d0f99a          DCFS     0x43d0f99a ; 417.95001220703125
                  |L8.628|
000274  462ffccc          DCFS     0x462ffccc ; 11263.19921875
                  |L8.632|
000278  25372e33          DCB      "%7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\t %7.3f\r\n",0
00027c  66092025
000280  372e3366
000284  09202537
000288  2e336609
00028c  2025372e
000290  33660920
000294  25372e33
000298  66092025
00029c  372e3366
0002a0  0d0a00  
0002a3  00                DCB      0

                          AREA ||i.MPU6050_Read_To_Calculate||, CODE, READONLY, ALIGN=1

                  MPU6050_Read_To_Calculate PROC
;;;379    //数据读取用于零偏计算
;;;380    void MPU6050_Read_To_Calculate(Origial_DATA *Origial_DATA__ACC_XYZ,Origial_DATA *Origial_DATA__GYRO_XYZ)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;381    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;382    	uint8_t Mpu6050_Data_Buf[14]={0};//传感器原始数据接收缓冲
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
00000e  9002              STR      r0,[sp,#8]
000010  9003              STR      r0,[sp,#0xc]
000012  9004              STR      r0,[sp,#0x10]
;;;383    	int32_t G_X=0,G_Y=0,G_Z=0,A_X=0,A_Y=0,A_Z=0;
000014  2600              MOVS     r6,#0
000016  2700              MOVS     r7,#0
000018  4680              MOV      r8,r0
00001a  4681              MOV      r9,r0
00001c  4682              MOV      r10,r0
00001e  4683              MOV      r11,r0
;;;384    	int32_t temp=0;
000020  9000              STR      r0,[sp,#0]
;;;385    	MPU_Read_Len(MPU_ADDR, MPU_ACCEL_XOUTH_REG,14,Mpu6050_Data_Buf);//模拟IIC读取数据
000022  ab01              ADD      r3,sp,#4
000024  220e              MOVS     r2,#0xe
000026  213b              MOVS     r1,#0x3b
000028  2068              MOVS     r0,#0x68
00002a  f7fffffe          BL       MPU_Read_Len
;;;386    	
;;;387    	 A_X=	(((int16_t)Mpu6050_Data_Buf[0]<<8)|Mpu6050_Data_Buf[1]);
00002e  f89d0005          LDRB     r0,[sp,#5]
000032  f89d1004          LDRB     r1,[sp,#4]
000036  ea402901          ORR      r9,r0,r1,LSL #8
;;;388    	 A_Y=	(((int16_t)Mpu6050_Data_Buf[2]<<8)|Mpu6050_Data_Buf[3]);
00003a  f89d0007          LDRB     r0,[sp,#7]
00003e  f89d1006          LDRB     r1,[sp,#6]
000042  ea402a01          ORR      r10,r0,r1,LSL #8
;;;389    	 A_Z=	(((int16_t)Mpu6050_Data_Buf[4]<<8)|Mpu6050_Data_Buf[5]);
000046  f89d0009          LDRB     r0,[sp,#9]
00004a  f89d1008          LDRB     r1,[sp,#8]
00004e  ea402b01          ORR      r11,r0,r1,LSL #8
;;;390    	// Temperature=	(((int16_t)Mpu6050_Data_Buf[6]<<8)|Mpu6050_Data_Buf[7]);//内部温度ADC
;;;391    	 G_X=	(((int16_t)Mpu6050_Data_Buf[8]<<8)|Mpu6050_Data_Buf[9]);
000052  f89d000d          LDRB     r0,[sp,#0xd]
000056  f89d100c          LDRB     r1,[sp,#0xc]
00005a  ea402601          ORR      r6,r0,r1,LSL #8
;;;392    	 G_Y=	(((int16_t)Mpu6050_Data_Buf[10]<<8)|Mpu6050_Data_Buf[11]);
00005e  f89d000f          LDRB     r0,[sp,#0xf]
000062  f89d100e          LDRB     r1,[sp,#0xe]
000066  ea402701          ORR      r7,r0,r1,LSL #8
;;;393    	 G_Z=	(((int16_t)Mpu6050_Data_Buf[12]<<8)|Mpu6050_Data_Buf[13]);
00006a  f89d0011          LDRB     r0,[sp,#0x11]
00006e  f89d1010          LDRB     r1,[sp,#0x10]
000072  ea402801          ORR      r8,r0,r1,LSL #8
;;;394    
;;;395    		#if IMU_CHIP_ROTATION==0  //0：以MPU6050+X轴为机头前方
;;;396    	
;;;397    
;;;398    	#elif IMU_CHIP_ROTATION==1//1：以MPU6050-X轴为机头前方
;;;399    	A_X=-A_X;
;;;400    	A_Y=-A_Y;
;;;401    	
;;;402    	G_X=-G_X;
;;;403    	G_Y=-G_Y;
;;;404    	
;;;405    	#elif IMU_CHIP_ROTATION==2//2：以MPU6050+Y轴为机头前方
;;;406    	temp=A_X;
;;;407    	A_X = A_Y;
;;;408    	A_Y =-temp;
;;;409    	
;;;410    	temp=G_X;
;;;411    	G_X = G_Y;
;;;412    	G_Y = -temp;
;;;413    	
;;;414    	#elif IMU_CHIP_ROTATION==3//3：以MPU6050-Y轴为机头前方
;;;415    	temp=A_X;
;;;416    	A_X=-A_Y;
;;;417    	A_Y= temp;
;;;418    
;;;419    	temp=G_X;
;;;420    	G_X =-G_Y;
;;;421    	G_Y = temp;
;;;422    	#endif
;;;423    	
;;;424    	Origial_DATA__ACC_XYZ->X=(int16_t)A_X;
000076  fa0ff089          SXTH     r0,r9
00007a  8020              STRH     r0,[r4,#0]
;;;425    	Origial_DATA__ACC_XYZ->Y=(int16_t)A_Y;
00007c  fa0ff08a          SXTH     r0,r10
000080  8060              STRH     r0,[r4,#2]
;;;426    	Origial_DATA__ACC_XYZ->Z=(int16_t)A_Z;
000082  fa0ff08b          SXTH     r0,r11
000086  80a0              STRH     r0,[r4,#4]
;;;427    	Origial_DATA__GYRO_XYZ->X=(int16_t)G_X;
000088  b230              SXTH     r0,r6
00008a  8028              STRH     r0,[r5,#0]
;;;428    	Origial_DATA__GYRO_XYZ->Y=(int16_t)G_Y;
00008c  b238              SXTH     r0,r7
00008e  8068              STRH     r0,[r5,#2]
;;;429    	Origial_DATA__GYRO_XYZ->Z=(int16_t)G_Z;
000090  fa0ff088          SXTH     r0,r8
000094  80a8              STRH     r0,[r5,#4]
;;;430    }
000096  b005              ADD      sp,sp,#0x14
000098  e8bd8ff0          POP      {r4-r11,pc}
;;;431    
                          ENDP


                          AREA ||i.MPU6050_Read_To_Use_||, CODE, READONLY, ALIGN=1

                  MPU6050_Read_To_Use_ PROC
;;;303    //数据读取用于解算使用
;;;304    void MPU6050_Read_To_Use_(Origial_DATA*Origial_DATA__ACC_XYZ,Origial_DATA*Origial_DATA__GYRO_XYZ,OFFSET*offset)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;305    {
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4614              MOV      r4,r2
;;;306    	uint8_t Mpu6050_Data_Buf[14]={0};//传感器原始数据接收缓冲
00000c  2000              MOVS     r0,#0
00000e  9003              STR      r0,[sp,#0xc]
000010  9004              STR      r0,[sp,#0x10]
000012  9005              STR      r0,[sp,#0x14]
000014  9006              STR      r0,[sp,#0x18]
;;;307    	int32_t G_X=0,G_Y=0,G_Z=0,A_X=0,A_Y=0,A_Z=0;
000016  2700              MOVS     r7,#0
000018  4680              MOV      r8,r0
00001a  4681              MOV      r9,r0
00001c  4682              MOV      r10,r0
00001e  4683              MOV      r11,r0
000020  9002              STR      r0,[sp,#8]
;;;308    	int32_t temp=0;
000022  9001              STR      r0,[sp,#4]
;;;309    	uint8_t res;
;;;310    	
;;;311    	MPU_Read_Len(MPU_ADDR, MPU_ACCEL_XOUTH_REG,14,Mpu6050_Data_Buf);//模拟IIC读取数据
000024  ab03              ADD      r3,sp,#0xc
000026  220e              MOVS     r2,#0xe
000028  213b              MOVS     r1,#0x3b
00002a  2068              MOVS     r0,#0x68
00002c  f7fffffe          BL       MPU_Read_Len
;;;312    
;;;313    	
;;;314    	 A_X=(((int16_t)Mpu6050_Data_Buf[0]<<8)|Mpu6050_Data_Buf[1])-offset->AX_Offset;
000030  f89d000d          LDRB     r0,[sp,#0xd]
000034  f89d100c          LDRB     r1,[sp,#0xc]
000038  ea402001          ORR      r0,r0,r1,LSL #8
00003c  f9b41000          LDRSH    r1,[r4,#0]
000040  eba00a01          SUB      r10,r0,r1
;;;315    	 A_Y=(((int16_t)Mpu6050_Data_Buf[2]<<8)|Mpu6050_Data_Buf[3])-offset->AY_Offset;
000044  f89d000f          LDRB     r0,[sp,#0xf]
000048  f89d100e          LDRB     r1,[sp,#0xe]
00004c  ea402001          ORR      r0,r0,r1,LSL #8
000050  f9b41002          LDRSH    r1,[r4,#2]
000054  eba00b01          SUB      r11,r0,r1
;;;316    	 A_Z=(((int16_t)Mpu6050_Data_Buf[4]<<8)|Mpu6050_Data_Buf[5])+offset->AZ_Offset;
000058  f89d0011          LDRB     r0,[sp,#0x11]
00005c  f89d1010          LDRB     r1,[sp,#0x10]
000060  ea402001          ORR      r0,r0,r1,LSL #8
000064  f9b41004          LDRSH    r1,[r4,#4]
000068  4408              ADD      r0,r0,r1
00006a  9002              STR      r0,[sp,#8]
;;;317    	
;;;318    	// Temperature=	(((int16_t)Mpu6050_Data_Buf[6]<<8)|Mpu6050_Data_Buf[7]);//内部温度ADC
;;;319    	 G_X=(((int16_t)Mpu6050_Data_Buf[8]<<8)|Mpu6050_Data_Buf[9])-offset->GX_Offset;
00006c  f89d0015          LDRB     r0,[sp,#0x15]
000070  f89d1014          LDRB     r1,[sp,#0x14]
000074  ea402001          ORR      r0,r0,r1,LSL #8
000078  f9b41006          LDRSH    r1,[r4,#6]
00007c  1a47              SUBS     r7,r0,r1
;;;320    	 G_Y=(((int16_t)Mpu6050_Data_Buf[10]<<8)|Mpu6050_Data_Buf[11])-offset->GY_Offset;
00007e  f89d0017          LDRB     r0,[sp,#0x17]
000082  f89d1016          LDRB     r1,[sp,#0x16]
000086  ea402001          ORR      r0,r0,r1,LSL #8
00008a  f9b41008          LDRSH    r1,[r4,#8]
00008e  eba00801          SUB      r8,r0,r1
;;;321    	 G_Z=(((int16_t)Mpu6050_Data_Buf[12]<<8)|Mpu6050_Data_Buf[13])-offset->GZ_Offset;
000092  f89d0019          LDRB     r0,[sp,#0x19]
000096  f89d1018          LDRB     r1,[sp,#0x18]
00009a  ea402001          ORR      r0,r0,r1,LSL #8
00009e  f9b4100a          LDRSH    r1,[r4,#0xa]
0000a2  eba00901          SUB      r9,r0,r1
;;;322    //	 u1_printf("%d\t%d\t%d\t%d\t%d\t%d\r\n",A_X,A_Y,A_Z,G_X,G_Y,G_Z);
;;;323    	 /***数据限幅***/
;;;324    // 	if(G_X>Data_Max) G_X=Data_Max;
;;;325    // 	if(G_X<Data_Min) G_X=Data_Min;
;;;326    // 	if(G_Y>Data_Max) G_Y=Data_Max;
;;;327    // 	if(G_Y<Data_Min) G_Y=Data_Min;
;;;328    // 	if(G_Z>Data_Max) G_Z=Data_Max;
;;;329    // 	if(G_Z<Data_Min) G_Z=Data_Min;
;;;330    // 	if(A_X>Data_Max) A_X=Data_Max;
;;;331    // 	if(A_X<Data_Min) A_X=Data_Min;
;;;332    // 	if(A_Y>Data_Max) A_Y=Data_Max;
;;;333    // 	if(A_Y<Data_Min) A_Y=Data_Min;
;;;334    //  if(A_Z>Data_Max) A_Z=Data_Max;
;;;335    //  if(A_Z<Data_Min) A_Z=Data_Min;
;;;336    	
;;;337    	#if IMU_CHIP_ROTATION==0  //0：以MPU6050+X轴为机头前方
;;;338    	
;;;339    
;;;340    	#elif IMU_CHIP_ROTATION==1//1：以MPU6050-X轴为机头前方
;;;341    	A_X=-A_X;
;;;342    	A_Y=-A_Y;
;;;343    	
;;;344    	G_X=-G_X;
;;;345    	G_Y=-G_Y;
;;;346    	
;;;347    	#elif IMU_CHIP_ROTATION==2//2：以MPU6050+Y轴为机头前方
;;;348    	temp=A_X;
;;;349    	A_X = A_Y;
;;;350    	A_Y =-temp;
;;;351    	
;;;352    	temp=G_X;
;;;353    	G_X = G_Y;
;;;354    	G_Y = -temp;
;;;355    	
;;;356    	#elif IMU_CHIP_ROTATION==3//3：以MPU6050-Y轴为机头前方
;;;357    	temp=A_X;
;;;358    	A_X=-A_Y;
;;;359    	A_Y= temp;
;;;360    
;;;361    	temp=G_X;
;;;362    	G_X =-G_Y;
;;;363    	G_Y = temp;
;;;364    	#endif
;;;365    	
;;;366    	Origial_DATA__ACC_XYZ->X=(int16_t)A_X;
0000a6  fa0ff08a          SXTH     r0,r10
0000aa  8028              STRH     r0,[r5,#0]
;;;367    	Origial_DATA__ACC_XYZ->Y=(int16_t)A_Y;
0000ac  fa0ff08b          SXTH     r0,r11
0000b0  8068              STRH     r0,[r5,#2]
;;;368    	Origial_DATA__ACC_XYZ->Z=(int16_t)A_Z;
0000b2  9802              LDR      r0,[sp,#8]
0000b4  b200              SXTH     r0,r0
0000b6  80a8              STRH     r0,[r5,#4]
;;;369    	Origial_DATA__GYRO_XYZ->X=(int16_t)G_X;
0000b8  b238              SXTH     r0,r7
0000ba  8030              STRH     r0,[r6,#0]
;;;370    	Origial_DATA__GYRO_XYZ->Y=(int16_t)G_Y;
0000bc  fa0ff088          SXTH     r0,r8
0000c0  8070              STRH     r0,[r6,#2]
;;;371    	Origial_DATA__GYRO_XYZ->Z=(int16_t)G_Z;
0000c2  fa0ff089          SXTH     r0,r9
0000c6  80b0              STRH     r0,[r6,#4]
;;;372    	
;;;373    // 	u1_printf("%d\t %d\t %d\t %d\t %d\t %d\r\n",Origial_DATA__ACC_XYZ->X,Origial_DATA__ACC_XYZ->Y,
;;;374    // 	Origial_DATA__ACC_XYZ->Z,Origial_DATA__GYRO_XYZ->X,Origial_DATA__GYRO_XYZ->Y,Origial_DATA__GYRO_XYZ->Z);
;;;375    
;;;376    }
0000c8  b007              ADD      sp,sp,#0x1c
0000ca  e8bd8ff0          POP      {r4-r11,pc}
;;;377    
                          ENDP


                          AREA ||i.MPU_Get_Accelerometer||, CODE, READONLY, ALIGN=1

                  MPU_Get_Accelerometer PROC
;;;182    //    其他,错误代码
;;;183    u8 MPU_Get_Accelerometer(short *ax,short *ay,short *az)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;184    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;185        u8 buf[6],res;
;;;186    	res=MPU_Read_Len(MPU_ADDR,MPU_ACCEL_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  213b              MOVS     r1,#0x3b
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;187    	if(res==0)
000018  b9bf              CBNZ     r7,|L11.74|
;;;188    	{
;;;189    		*ax=((u16)buf[0]<<8)|buf[1];
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;190    		*ay=((u16)buf[2]<<8)|buf[3];
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;191    		*az=((u16)buf[4]<<8)|buf[5];
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L11.74|
;;;192    	}
;;;193        return res;;
00004a  4638              MOV      r0,r7
;;;194    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;195    //IIC连续写
                          ENDP


                          AREA ||i.MPU_Get_Gyroscope||, CODE, READONLY, ALIGN=1

                  MPU_Get_Gyroscope PROC
;;;162    
;;;163    u8 MPU_Get_Gyroscope(short *gx,short *gy,short *gz)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;164    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;165        u8 buf[6],res;
;;;166    	
;;;167    	res=MPU_Read_Len(MPU_ADDR,MPU_GYRO_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  2143              MOVS     r1,#0x43
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;168    	if(res==0)
000018  b9bf              CBNZ     r7,|L12.74|
;;;169    	{
;;;170    		*gx=(short)(((u16)buf[0]<<8)|buf[1]);
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;171    		*gy=(short)(((u16)buf[2]<<8)|buf[3]);
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;172    		*gz=(short)(((u16)buf[4]<<8)|buf[5]);
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L12.74|
;;;173    ////		*gx=(short)(((u16)buf[0]<<8)|buf[1]) + 21;
;;;174    ////		*gy=(short)(((u16)buf[2]<<8)|buf[3]) - 10;
;;;175    ////		*gz=(short)(((u16)buf[4]<<8)|buf[5]) + 3;
;;;176    	}
;;;177        return res;;
00004a  4638              MOV      r0,r7
;;;178    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;179    //得到加速度值(原始值)
                          ENDP


                          AREA ||i.MPU_Get_Temperature||, CODE, READONLY, ALIGN=2

                  MPU_Get_Temperature PROC
;;;147    //返回值:温度值(扩大了100倍)
;;;148    short MPU_Get_Temperature(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
000002  ed2d8b08          VPUSH    {d8-d11}
000006  b082              SUB      sp,sp,#8
;;;150        u8 buf[2];
;;;151        short raw;
;;;152    	float temp;
;;;153    	MPU_Read_Len(MPU_ADDR,MPU_TEMP_OUTH_REG,2,buf);
000008  ab01              ADD      r3,sp,#4
00000a  2202              MOVS     r2,#2
00000c  2141              MOVS     r1,#0x41
00000e  2068              MOVS     r0,#0x68
000010  f7fffffe          BL       MPU_Read_Len
;;;154        raw=((u16)buf[0]<<8)|buf[1];
000014  f89d0005          LDRB     r0,[sp,#5]
000018  f89d1004          LDRB     r1,[sp,#4]
00001c  ea402001          ORR      r0,r0,r1,LSL #8
000020  b204              SXTH     r4,r0
;;;155        temp=36.53+((double)raw)/340;
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       __aeabi_i2d
000028  ec410b1b          VMOV     d11,r0,r1
00002c  ed9f0b10          VLDR     d0,|L13.112|
000030  ec532b10          VMOV     r2,r3,d0
000034  f7fffffe          BL       __aeabi_ddiv
000038  ec410b1a          VMOV     d10,r0,r1
00003c  ed9f0b0e          VLDR     d0,|L13.120|
000040  ec532b10          VMOV     r2,r3,d0
000044  f7fffffe          BL       __aeabi_dadd
000048  ec410b19          VMOV     d9,r0,r1
00004c  f7fffffe          BL       __aeabi_d2f
000050  ee080a10          VMOV     s16,r0
;;;156        return temp*100;;
000054  ed9f0a0a          VLDR     s0,|L13.128|
000058  ee280a00          VMUL.F32 s0,s16,s0
00005c  eebd0ac0          VCVT.S32.F32 s0,s0
000060  ee100a10          VMOV     r0,s0
000064  b200              SXTH     r0,r0
;;;157    }
000066  b002              ADD      sp,sp,#8
000068  ecbd8b08          VPOP     {d8-d11}
00006c  bd10              POP      {r4,pc}
;;;158    //得到陀螺仪值(原始值)
                          ENDP

00006e  0000              DCW      0x0000
                  |L13.112|
000070  00000000          DCFD     0x4075400000000000 ; 340
000074  40754000
                  |L13.120|
000078  0a3d70a4          DCFD     0x404243d70a3d70a4 ; 36.530000000000001
00007c  404243d7
                  |L13.128|
000080  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.MPU_Init||, CODE, READONLY, ALIGN=1

                  MPU_Init PROC
;;;69     //    其他,错误代码
;;;70     u8 MPU_Init(void)
000000  b510              PUSH     {r4,lr}
;;;71     {
;;;72     	u8 res;
;;;73     	IIC_Init();//初始化IIC总线
000002  f7fffffe          BL       IIC_Init
;;;74     	
;;;75     //	RunTime(StartCheck);
;;;76     //	delay_ms(1000);
;;;77     //	RunTime(StopCheck);
;;;78     		
;;;79     	
;;;80     	MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X80);	//复位MPU6050
000006  2180              MOVS     r1,#0x80
000008  206b              MOVS     r0,#0x6b
00000a  f7fffffe          BL       MPU_Write_Byte
;;;81     	
;;;82         delay_ms_nos(100);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       delay_ms_nos
;;;83     	
;;;84     	MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X00);	//唤醒MPU6050
000014  2100              MOVS     r1,#0
000016  206b              MOVS     r0,#0x6b
000018  f7fffffe          BL       MPU_Write_Byte
;;;85     	MPU_Set_Gyro_Fsr(3);					//陀螺仪传感器,±2000dps
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       MPU_Set_Gyro_Fsr
;;;86     	MPU_Set_Accel_Fsr(2);					//加速度传感器,±2g//±8g
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       MPU_Set_Accel_Fsr
;;;87     	MPU_Set_Rate(1000);						//设置采样率50Hz
000028  f44f707a          MOV      r0,#0x3e8
00002c  f7fffffe          BL       MPU_Set_Rate
;;;88     	MPU_Write_Byte(MPU_INT_EN_REG,0X00);	//关闭所有中断
000030  2100              MOVS     r1,#0
000032  2038              MOVS     r0,#0x38
000034  f7fffffe          BL       MPU_Write_Byte
;;;89     	MPU_Write_Byte(MPU_USER_CTRL_REG,0X00);	//I2C主模式关闭
000038  2100              MOVS     r1,#0
00003a  206a              MOVS     r0,#0x6a
00003c  f7fffffe          BL       MPU_Write_Byte
;;;90     	MPU_Write_Byte(MPU_FIFO_EN_REG,0X00);	//关闭FIFO
000040  2100              MOVS     r1,#0
000042  2023              MOVS     r0,#0x23
000044  f7fffffe          BL       MPU_Write_Byte
;;;91     	MPU_Write_Byte(MPU_INTBP_CFG_REG,0X80);	//INT引脚低电平有效
000048  2180              MOVS     r1,#0x80
00004a  2037              MOVS     r0,#0x37
00004c  f7fffffe          BL       MPU_Write_Byte
;;;92     	res=MPU_Read_Byte(MPU_DEVICE_ID_REG);
000050  2075              MOVS     r0,#0x75
000052  f7fffffe          BL       MPU_Read_Byte
000056  4604              MOV      r4,r0
;;;93     	if(res==MPU_ADDR)//器件ID正确
000058  2c68              CMP      r4,#0x68
00005a  d10c              BNE      |L14.118|
;;;94     	{
;;;95     		MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X01);	//设置CLKSEL,PLL X轴为参考
00005c  2101              MOVS     r1,#1
00005e  206b              MOVS     r0,#0x6b
000060  f7fffffe          BL       MPU_Write_Byte
;;;96     		MPU_Write_Byte(MPU_PWR_MGMT2_REG,0X00);	//加速度与陀螺仪都工作
000064  2100              MOVS     r1,#0
000066  206c              MOVS     r0,#0x6c
000068  f7fffffe          BL       MPU_Write_Byte
;;;97     		MPU_Set_Rate(1000);						//设置采样率为50Hz
00006c  f44f707a          MOV      r0,#0x3e8
000070  f7fffffe          BL       MPU_Set_Rate
000074  e001              B        |L14.122|
                  |L14.118|
;;;98      	}else return 1;
000076  2001              MOVS     r0,#1
                  |L14.120|
;;;99     	return 0;
;;;100    }
000078  bd10              POP      {r4,pc}
                  |L14.122|
00007a  2000              MOVS     r0,#0                 ;99
00007c  e7fc              B        |L14.120|
;;;101    //设置MPU6050陀螺仪传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Read_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Read_Byte PROC
;;;284    //返回值:读到的数据
;;;285    u8 MPU_Read_Byte(u8 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
000002  4604              MOV      r4,r0
;;;287    	u8 res;
;;;288        IIC_Start();
000004  f7fffffe          BL       IIC_Start
;;;289    	IIC_Send_Byte((MPU_ADDR<<1)|0);//发送器件地址+写命令
000008  20d0              MOVS     r0,#0xd0
00000a  f7fffffe          BL       IIC_Send_Byte
;;;290    	IIC_Wait_Ack();		//等待应答
00000e  f7fffffe          BL       IIC_Wait_Ack
;;;291        IIC_Send_Byte(reg);	//写寄存器地址
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       IIC_Send_Byte
;;;292        IIC_Wait_Ack();		//等待应答
000018  f7fffffe          BL       IIC_Wait_Ack
;;;293        IIC_Start();
00001c  f7fffffe          BL       IIC_Start
;;;294    	IIC_Send_Byte((MPU_ADDR<<1)|1);//发送器件地址+读命令
000020  20d1              MOVS     r0,#0xd1
000022  f7fffffe          BL       IIC_Send_Byte
;;;295        IIC_Wait_Ack();		//等待应答
000026  f7fffffe          BL       IIC_Wait_Ack
;;;296    	res=IIC_Read_Byte(0);//读取数据,发送nACK
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       IIC_Read_Byte
000030  4605              MOV      r5,r0
;;;297        IIC_Stop();			//产生一个停止条件
000032  f7fffffe          BL       IIC_Stop
;;;298    	return res;
000036  4628              MOV      r0,r5
;;;299    }
000038  bd70              POP      {r4-r6,pc}
;;;300    
                          ENDP


                          AREA ||i.MPU_Read_Len||, CODE, READONLY, ALIGN=1

                  MPU_Read_Len PROC
;;;232    //    其他,错误代码
;;;233    u8 MPU_Read_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;234    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;235     	IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;236    	IIC_Send_Byte((addr<<1)|0);//发送器件地址+写命令
000010  2100              MOVS     r1,#0
000012  ea410146          ORR      r1,r1,r6,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       IIC_Send_Byte
;;;237    	if(IIC_Wait_Ack())	//等待应答
00001c  f7fffffe          BL       IIC_Wait_Ack
000020  b120              CBZ      r0,|L16.44|
;;;238    	{
;;;239    		IIC_Stop();
000022  f7fffffe          BL       IIC_Stop
;;;240    		return 1;
000026  2001              MOVS     r0,#1
                  |L16.40|
;;;241    	}
;;;242        IIC_Send_Byte(reg);	//写寄存器地址
;;;243        IIC_Wait_Ack();		//等待应答
;;;244        IIC_Start();
;;;245    	IIC_Send_Byte((addr<<1)|1);//发送器件地址+读命令
;;;246        IIC_Wait_Ack();		//等待应答
;;;247    	while(len)
;;;248    	{
;;;249    		if(len==1)*buf=IIC_Read_Byte(0);//读数据,发送nACK
;;;250    		else *buf=IIC_Read_Byte(1);		//读数据,发送ACK
;;;251    		len--;
;;;252    		buf++;
;;;253    	}
;;;254        IIC_Stop();	//产生一个停止条件
;;;255    	return 0;
;;;256    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L16.44|
00002c  4638              MOV      r0,r7                 ;242
00002e  f7fffffe          BL       IIC_Send_Byte
000032  f7fffffe          BL       IIC_Wait_Ack
000036  f7fffffe          BL       IIC_Start
00003a  2101              MOVS     r1,#1                 ;245
00003c  eb010146          ADD      r1,r1,r6,LSL #1       ;245
000040  b2c8              UXTB     r0,r1                 ;245
000042  f7fffffe          BL       IIC_Send_Byte
000046  f7fffffe          BL       IIC_Wait_Ack
00004a  e00d              B        |L16.104|
                  |L16.76|
00004c  2c01              CMP      r4,#1                 ;249
00004e  d104              BNE      |L16.90|
000050  2000              MOVS     r0,#0                 ;249
000052  f7fffffe          BL       IIC_Read_Byte
000056  7028              STRB     r0,[r5,#0]            ;249
000058  e003              B        |L16.98|
                  |L16.90|
00005a  2001              MOVS     r0,#1                 ;250
00005c  f7fffffe          BL       IIC_Read_Byte
000060  7028              STRB     r0,[r5,#0]            ;250
                  |L16.98|
000062  1e60              SUBS     r0,r4,#1              ;251
000064  b2c4              UXTB     r4,r0                 ;251
000066  1c6d              ADDS     r5,r5,#1              ;252
                  |L16.104|
000068  2c00              CMP      r4,#0                 ;247
00006a  d1ef              BNE      |L16.76|
00006c  f7fffffe          BL       IIC_Stop
000070  2000              MOVS     r0,#0                 ;255
000072  e7d9              B        |L16.40|
;;;257    //IIC写一个字节
                          ENDP


                          AREA ||i.MPU_Set_Accel_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Accel_Fsr PROC
;;;112    //    其他,设置失败
;;;113    u8 MPU_Set_Accel_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;114    {
000002  4604              MOV      r4,r0
;;;115    	return MPU_Write_Byte(MPU_ACCEL_CFG_REG,fsr<<3);//设置加速度传感器满量程范围
000004  06e0              LSLS     r0,r4,#27
000006  0e01              LSRS     r1,r0,#24
000008  201c              MOVS     r0,#0x1c
00000a  f7fffffe          BL       MPU_Write_Byte
;;;116    }
00000e  bd10              POP      {r4,pc}
;;;117    //设置MPU6050的数字低通滤波器
                          ENDP


                          AREA ||i.MPU_Set_Gyro_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Gyro_Fsr PROC
;;;104    //    其他,设置失败
;;;105    u8 MPU_Set_Gyro_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;106    {
000002  4604              MOV      r4,r0
;;;107    	return MPU_Write_Byte(MPU_GYRO_CFG_REG,fsr<<3);//设置陀螺仪满量程范围
000004  06e0              LSLS     r0,r4,#27
000006  0e01              LSRS     r1,r0,#24
000008  201b              MOVS     r0,#0x1b
00000a  f7fffffe          BL       MPU_Write_Byte
;;;108    }
00000e  bd10              POP      {r4,pc}
;;;109    //设置MPU6050加速度传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Set_LPF||, CODE, READONLY, ALIGN=1

                  MPU_Set_LPF PROC
;;;120    //    其他,设置失败
;;;121    u8 MPU_Set_LPF(u16 lpf)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  4604              MOV      r4,r0
;;;123    	u8 data=0;
000004  2500              MOVS     r5,#0
;;;124    	if(lpf>=188)data=1;
000006  2cbc              CMP      r4,#0xbc
000008  db01              BLT      |L19.14|
00000a  2501              MOVS     r5,#1
00000c  e010              B        |L19.48|
                  |L19.14|
;;;125    	else if(lpf>=98)data=2;
00000e  2c62              CMP      r4,#0x62
000010  db01              BLT      |L19.22|
000012  2502              MOVS     r5,#2
000014  e00c              B        |L19.48|
                  |L19.22|
;;;126    	else if(lpf>=42)data=3;
000016  2c2a              CMP      r4,#0x2a
000018  db01              BLT      |L19.30|
00001a  2503              MOVS     r5,#3
00001c  e008              B        |L19.48|
                  |L19.30|
;;;127    	else if(lpf>=20)data=4;
00001e  2c14              CMP      r4,#0x14
000020  db01              BLT      |L19.38|
000022  2504              MOVS     r5,#4
000024  e004              B        |L19.48|
                  |L19.38|
;;;128    	else if(lpf>=10)data=5;
000026  2c0a              CMP      r4,#0xa
000028  db01              BLT      |L19.46|
00002a  2505              MOVS     r5,#5
00002c  e000              B        |L19.48|
                  |L19.46|
;;;129    	else data=6;
00002e  2506              MOVS     r5,#6
                  |L19.48|
;;;130    	return MPU_Write_Byte(MPU_CFG_REG,data);//设置数字低通滤波器
000030  4629              MOV      r1,r5
000032  201a              MOVS     r0,#0x1a
000034  f7fffffe          BL       MPU_Write_Byte
;;;131    }
000038  bd70              POP      {r4-r6,pc}
;;;132    //设置MPU6050的采样率(假定Fs=1KHz)
                          ENDP


                          AREA ||i.MPU_Set_Rate||, CODE, READONLY, ALIGN=1

                  MPU_Set_Rate PROC
;;;135    //    其他,设置失败
;;;136    u8 MPU_Set_Rate(u16 rate)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
000002  4604              MOV      r4,r0
;;;138    	u8 data;
;;;139    	if(rate>1000)rate=1000;
000004  f5b47f7a          CMP      r4,#0x3e8
000008  dd01              BLE      |L20.14|
00000a  f44f747a          MOV      r4,#0x3e8
                  |L20.14|
;;;140    	if(rate<4)rate=4;
00000e  2c04              CMP      r4,#4
000010  da00              BGE      |L20.20|
000012  2404              MOVS     r4,#4
                  |L20.20|
;;;141    	data=1000/rate-1;
000014  f44f707a          MOV      r0,#0x3e8
000018  fb90f0f4          SDIV     r0,r0,r4
00001c  1e40              SUBS     r0,r0,#1
00001e  b2c5              UXTB     r5,r0
;;;142    	data=MPU_Write_Byte(MPU_SAMPLE_RATE_REG,data);	//设置数字低通滤波器
000020  4629              MOV      r1,r5
000022  2019              MOVS     r0,#0x19
000024  f7fffffe          BL       MPU_Write_Byte
000028  4605              MOV      r5,r0
;;;143     	return MPU_Set_LPF(rate/2);	//自动设置LPF为采样率的一半
00002a  4626              MOV      r6,r4
00002c  eb0471d6          ADD      r1,r4,r6,LSR #31
000030  f3c1004f          UBFX     r0,r1,#1,#16
000034  f7fffffe          BL       MPU_Set_LPF
;;;144    }
000038  bd70              POP      {r4-r6,pc}
;;;145    
                          ENDP


                          AREA ||i.MPU_Write_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Write_Byte PROC
;;;261    //    其他,错误代码
;;;262    u8 MPU_Write_Byte(u8 reg,u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;264        IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;265    	IIC_Send_Byte((MPU_ADDR<<1)|0);//发送器件地址+写命令
00000a  20d0              MOVS     r0,#0xd0
00000c  f7fffffe          BL       IIC_Send_Byte
;;;266    	if(IIC_Wait_Ack())	//等待应答
000010  f7fffffe          BL       IIC_Wait_Ack
000014  b118              CBZ      r0,|L21.30|
;;;267    	{
;;;268    		IIC_Stop();
000016  f7fffffe          BL       IIC_Stop
;;;269    		return 1;
00001a  2001              MOVS     r0,#1
                  |L21.28|
;;;270    	}
;;;271        IIC_Send_Byte(reg);	//写寄存器地址
;;;272        IIC_Wait_Ack();		//等待应答
;;;273    	IIC_Send_Byte(data);//发送数据
;;;274    	if(IIC_Wait_Ack())	//等待ACK
;;;275    	{
;;;276    		IIC_Stop();
;;;277    		return 1;
;;;278    	}
;;;279        IIC_Stop();
;;;280    	return 0;
;;;281    }
00001c  bd70              POP      {r4-r6,pc}
                  |L21.30|
00001e  4628              MOV      r0,r5                 ;271
000020  f7fffffe          BL       IIC_Send_Byte
000024  f7fffffe          BL       IIC_Wait_Ack
000028  4620              MOV      r0,r4                 ;273
00002a  f7fffffe          BL       IIC_Send_Byte
00002e  f7fffffe          BL       IIC_Wait_Ack
000032  b118              CBZ      r0,|L21.60|
000034  f7fffffe          BL       IIC_Stop
000038  2001              MOVS     r0,#1                 ;277
00003a  e7ef              B        |L21.28|
                  |L21.60|
00003c  f7fffffe          BL       IIC_Stop
000040  2000              MOVS     r0,#0                 ;280
000042  e7eb              B        |L21.28|
;;;282    //IIC读一个字节
                          ENDP


                          AREA ||i.MPU_Write_Len||, CODE, READONLY, ALIGN=1

                  MPU_Write_Len PROC
;;;201    //    其他,错误代码
;;;202    u8 MPU_Write_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;203    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;204    	u8 i;
;;;205        IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;206    	IIC_Send_Byte((addr<<1)|0);//发送器件地址+写命令
000010  2100              MOVS     r1,#0
000012  ea410145          ORR      r1,r1,r5,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       IIC_Send_Byte
;;;207    	if(IIC_Wait_Ack())	//等待应答
00001c  f7fffffe          BL       IIC_Wait_Ack
000020  b120              CBZ      r0,|L22.44|
;;;208    	{
;;;209    		IIC_Stop();
000022  f7fffffe          BL       IIC_Stop
;;;210    		return 1;
000026  2001              MOVS     r0,#1
                  |L22.40|
;;;211    	}
;;;212        IIC_Send_Byte(reg);	//写寄存器地址
;;;213        IIC_Wait_Ack();		//等待应答
;;;214    	for(i=0;i<len;i++)
;;;215    	{
;;;216    		IIC_Send_Byte(buf[i]);	//发送数据
;;;217    		if(IIC_Wait_Ack())		//等待ACK
;;;218    		{
;;;219    			IIC_Stop();
;;;220    			return 1;
;;;221    		}
;;;222    	}
;;;223        IIC_Stop();
;;;224    	return 0;
;;;225    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L22.44|
00002c  4630              MOV      r0,r6                 ;212
00002e  f7fffffe          BL       IIC_Send_Byte
000032  f7fffffe          BL       IIC_Wait_Ack
000036  2400              MOVS     r4,#0                 ;214
000038  e00c              B        |L22.84|
                  |L22.58|
00003a  f8180004          LDRB     r0,[r8,r4]            ;216
00003e  f7fffffe          BL       IIC_Send_Byte
000042  f7fffffe          BL       IIC_Wait_Ack
000046  b118              CBZ      r0,|L22.80|
000048  f7fffffe          BL       IIC_Stop
00004c  2001              MOVS     r0,#1                 ;220
00004e  e7eb              B        |L22.40|
                  |L22.80|
000050  1c60              ADDS     r0,r4,#1              ;214
000052  b2c4              UXTB     r4,r0                 ;214
                  |L22.84|
000054  42bc              CMP      r4,r7                 ;214
000056  dbf0              BLT      |L22.58|
000058  f7fffffe          BL       IIC_Stop
00005c  2000              MOVS     r0,#0                 ;224
00005e  e7e3              B        |L22.40|
;;;226    //IIC连续读
                          ENDP


                          AREA ||i.imu_update||, CODE, READONLY, ALIGN=2

                  imu_update PROC
;;;633    //返回：无
;;;634    void imu_update(Data_To_Imu*velocity,Data_To_Imu*acc,EULLA*eulla,float dt)
000000  b5f0              PUSH     {r4-r7,lr}
;;;635    {
000002  ed2d8b10          VPUSH    {d8-d15}
000006  b089              SUB      sp,sp,#0x24
000008  4605              MOV      r5,r0
00000a  460c              MOV      r4,r1
00000c  4616              MOV      r6,r2
00000e  eef08a40          VMOV.F32 s17,s0
;;;636      float vx=0.0f, vy=0.0f, vz=0.0f;//当前的欧拉角(四元数)的机体坐标参照系上，换算出来的重力单位向量
000012  ed9f0afe          VLDR     s0,|L23.1036|
000016  eeb09a40          VMOV.F32 s18,s0
00001a  ed9f0afc          VLDR     s0,|L23.1036|
00001e  eef09a40          VMOV.F32 s19,s0
000022  ed9f0afa          VLDR     s0,|L23.1036|
000026  eeb0aa40          VMOV.F32 s20,s0
;;;637      float ex=0.0f, ey=0.0f, ez=0.0f;//陀螺仪积分后的姿态和计算出来的姿态误差
00002a  ed9f0af8          VLDR     s0,|L23.1036|
00002e  eef0aa40          VMOV.F32 s21,s0
000032  ed9f0af6          VLDR     s0,|L23.1036|
000036  eeb0da40          VMOV.F32 s26,s0
00003a  ed9f0af4          VLDR     s0,|L23.1036|
00003e  eef0da40          VMOV.F32 s27,s0
;;;638      //double t[3][3]; //存放方向余弦矩阵数组
;;;639      float norm=0.0f;//模向量变量
000042  ed9f0af2          VLDR     s0,|L23.1036|
000046  eeb08a40          VMOV.F32 s16,s0
;;;640    	//double yaw_mag;//磁力计解算出的偏航
;;;641      float gyro_vel_z=velocity->Z;
00004a  ed950a02          VLDR     s0,[r5,#8]
00004e  eeb0ea40          VMOV.F32 s28,s0
;;;642    /*************为后面数据计算准备*********/
;;;643    	float q0q0 = q[0]*q[0];
000052  48ef              LDR      r0,|L23.1040|
000054  ed900a00          VLDR     s0,[r0,#0]
000058  ee200a00          VMUL.F32 s0,s0,s0
00005c  eef0ea40          VMOV.F32 s29,s0
;;;644    	float q0q1 = q[0]*q[1];
000060  ed900a00          VLDR     s0,[r0,#0]
000064  edd00a01          VLDR     s1,[r0,#4]
000068  ee200a20          VMUL.F32 s0,s0,s1
00006c  ed8d0a08          VSTR     s0,[sp,#0x20]
;;;645    	float q0q2 = q[0]*q[2];
000070  ed900a00          VLDR     s0,[r0,#0]
000074  edd00a02          VLDR     s1,[r0,#8]
000078  ee200a20          VMUL.F32 s0,s0,s1
00007c  ed8d0a07          VSTR     s0,[sp,#0x1c]
;;;646    	//float q0q3 = q[0]*q[3];	
;;;647    	float q1q1 = q[1]*q[1];
000080  ed900a01          VLDR     s0,[r0,#4]
000084  ee200a00          VMUL.F32 s0,s0,s0
000088  ed8d0a06          VSTR     s0,[sp,#0x18]
;;;648    	//float q1q2 = q[1]*q[2];	
;;;649    	float q1q3 = q[1]*q[3];
00008c  ed900a01          VLDR     s0,[r0,#4]
000090  edd00a03          VLDR     s1,[r0,#0xc]
000094  ee200a20          VMUL.F32 s0,s0,s1
000098  ed8d0a05          VSTR     s0,[sp,#0x14]
;;;650    	float q2q2 = q[2]*q[2];
00009c  ed900a02          VLDR     s0,[r0,#8]
0000a0  ee200a00          VMUL.F32 s0,s0,s0
0000a4  ed8d0a04          VSTR     s0,[sp,#0x10]
;;;651    	float q2q3 = q[2]*q[3];
0000a8  ed900a02          VLDR     s0,[r0,#8]
0000ac  edd00a03          VLDR     s1,[r0,#0xc]
0000b0  ee200a20          VMUL.F32 s0,s0,s1
0000b4  ed8d0a03          VSTR     s0,[sp,#0xc]
;;;652    	float q3q3 = q[3]*q[3];
0000b8  ed900a03          VLDR     s0,[r0,#0xc]
0000bc  ee200a00          VMUL.F32 s0,s0,s0
0000c0  ed8d0a02          VSTR     s0,[sp,#8]
;;;653    	
;;;654    //	u1_printf("1\r\n");
;;;655    //	u1_printf("%7.3f\t%7.3f\t%7.3f\r\n",acc->X,acc->Y,acc->Z );
;;;656    	if(acc->X*acc->Y*acc->Z==0) return;	
0000c4  ed940a00          VLDR     s0,[r4,#0]
0000c8  edd40a01          VLDR     s1,[r4,#4]
0000cc  ee200a20          VMUL.F32 s0,s0,s1
0000d0  edd40a02          VLDR     s1,[r4,#8]
0000d4  ee200a20          VMUL.F32 s0,s0,s1
0000d8  eeb50ac0          VCMPE.F32 s0,#0.0
0000dc  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000e0  d103              BNE      |L23.234|
                  |L23.226|
;;;657    //	u1_printf("2\r\n");
;;;658    	if(gyro_vel_z<0.0015f) gyro_vel_z=0;
;;;659    //u1_printf("3\r\n");
;;;660    	Inerialacc.acctemp=(acc->X*acc->X + acc->Y*acc->Y + acc->Z*acc->Z)/(9.8f*9.8f);
;;;661    	if(0.55f<Inerialacc.acctemp && Inerialacc.acctemp<1.21f)
;;;662    	{
;;;663    		Kp=KP;
;;;664    	}
;;;665    	else
;;;666    	{
;;;667    		Kp=0;//不采用加速度计补偿矫正陀螺仪积分算出的角度
;;;668    	}
;;;669    	norm=Invsqrt(acc->X*acc->X + acc->Y*acc->Y + acc->Z*acc->Z);//快速求方根倒数
;;;670    //	u1_printf("4\r\n");
;;;671    	Inerialacc.acclength=acc->Z*norm;//规范化后的acc->Z
;;;672    	if(Inerialacc.acclength<0.05f)
;;;673    	{
;;;674    		Inerialacc.acccorr=0;
;;;675    	}
;;;676    	else
;;;677    	{
;;;678    		Inerialacc.acccorr=sinf(acosf(Inerialacc.acccorr));
;;;679    	}
;;;680    	  acc->X = acc->X * norm;
;;;681    	  acc->Y = acc->Y * norm;//把加计三位向量转换为单位向量
;;;682    	  acc->Z = acc->Z * norm;//基于机体坐标所测得的重力向量
;;;683    				
;;;684    	  vx = 2*(q1q3 - q0q2);	//陀螺仪积分后推算的姿态											
;;;685    	  vy = 2*(q0q1 + q2q3);//当前的欧拉角(四元数)的机体坐标参照系上，换算出来的重力单位向量
;;;686    	  vz = q0q0 - q1q1 - q2q2 + q3q3 ;//刚好是方向余弦中第三行的三个元素
;;;687    //	  vz = -0.5f+q0q0 + q3q3 ;//刚好是方向余弦中第三行的三个元素
;;;688    	
;;;689    	  ex = (acc->Y*vz - acc->Z*vy) ; //陀螺仪积分后的推算姿态和加计测量后的姿态之间的误差                          					
;;;690    	  ey = (acc->Z*vx - acc->X*vz) ;
;;;691    	  ez = (acc->X*vy - acc->Y*vx) ;
;;;692    	//向量之间的误差，可以用向量叉积(也叫向量外积，叉乘)来表示，ex,ey,ez就是两个重力向量vxyz 和acc->x y z的叉乘。
;;;693    	//这个叉积向量仍旧是位于机体坐标系上的，而陀螺仪积分误差也是基于机体坐标系，而且叉乘的大小与陀螺仪积分误差成
;;;694    	//正比，正好拿来纠正陀螺仪。
;;;695    	/*********误差积分********/		
;;;696    	  exInt = exInt + ex * Ki;							 
;;;697    	  eyInt = eyInt + ey * Ki;
;;;698    	  ezInt = ezInt + ez * Ki;
;;;699    /*********用叉积误差来做PI修正陀螺仪零偏********/
;;;700      velocity->X = velocity->X + Kp*ex + exInt;//P、I控制					   							
;;;701      velocity->Y = velocity->Y + Kp*ey + eyInt;
;;;702      velocity->Z = velocity->Z + Kp*ez + ezInt;//由于Z轴转动无法通过加计测量，所以不需要积分环节
;;;703    													//这里的gz由于没有观测者进行矫正会产生漂移，表现出来的就是积分自增或自减
;;;704     		   							
;;;705    	/********龙格库塔法更新四元数，halfT为采样周期的一半**********/				   
;;;706    	// integrate quaternion rate and normalise //四元数更新方程
;;;707    	q[0] = q[0] + (-q[1]*velocity->X - q[2]*velocity->Y - q[3]*velocity->Z)*dt/2;
;;;708    	q[1] = q[1] + ( q[0]*velocity->X + q[2]*velocity->Z - q[3]*velocity->Y)*dt/2;
;;;709    	q[2] = q[2] + ( q[0]*velocity->Y - q[1]*velocity->Z + q[3]*velocity->X)*dt/2;
;;;710    	q[3] = q[3] + ( q[0]*velocity->Z + q[1]*velocity->Y - q[2]*velocity->X)*dt/2;
;;;711    
;;;712    	norm = Invsqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);//快速求方根倒数
;;;713    	q[0] = q[0] * norm;//更新四元数
;;;714    	q[1] = q[1] * norm;
;;;715    	q[2] = q[2] * norm;
;;;716    	q[3] = q[3] * norm;
;;;717    	
;;;718    /***********再次更新数据*************/
;;;719    //   q0q0=q[0]*q[0];
;;;720    //   q0q1=q[0]*q[1];
;;;721    //   q0q2=q[0]*q[2];
;;;722    //   //q0q3=q[0]*q[3];
;;;723    //   q1q1=q[1]*q[1];
;;;724    //  // q1q2=q[1]*q[2];
;;;725    //   q1q3=q[1]*q[3];
;;;726    //   q2q2=q[2]*q[2];
;;;727    //   q2q3=q[2]*q[3];
;;;728    //   q3q3=q[3]*q[3];
;;;729    	
;;;730    /*************更新方向余弦矩阵***********/
;;;731    //     t[1][2]=2.0*(q2q3+q0q1); //y 
;;;732    //     t[2][2]=q0q0-q1q1-q2q2+q3q3; //z
;;;733    //     t[0][2]=2.0*(q1q3-q0q2); 	//x
;;;734    //     t[0][1]=2.0*(q1q2+q0q3);
;;;735    //     t[0][0]=q0q0+q1q1-q2q2-q3q3;
;;;736    
;;;737    //	eulla->yaw = atan2(2 * q[1] * q[2] + 2 * q[0] * q[3], -2 * q[2]*q[2] - 2 * q[3]* q[3] + 1)* 57.3; // 绕 z轴旋转
;;;738    	eulla->yaw  += gyro_vel_z*dt*57.3f;
;;;739     	eulla->pitch = sinf(-2 * q[1] * q[3] + 2 * q[0]* q[2])* 57.3; //绕 y轴旋转 -90°~+90°
;;;740     	eulla->roll  = atan2(2 * q[2] * q[3] + 2 * q[0] * q[1], -2 * q[1] * q[1] - 2 * q[2]* q[2] + 1) * 57.3; // 绕 x轴旋转 -180°~+180°
;;;741    	
;;;742    //	delay_ms(5);
;;;743    //u1_printf("5\r\n");
;;;744    }
0000e2  b009              ADD      sp,sp,#0x24
0000e4  ecbd8b10          VPOP     {d8-d15}
0000e8  bdf0              POP      {r4-r7,pc}
                  |L23.234|
0000ea  ed9f0aca          VLDR     s0,|L23.1044|
0000ee  eeb4eac0          VCMPE.F32 s28,s0                ;658
0000f2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;658
0000f6  d203              BCS      |L23.256|
0000f8  ed9f0ac4          VLDR     s0,|L23.1036|
0000fc  eeb0ea40          VMOV.F32 s28,s0                ;658
                  |L23.256|
000100  ed940a00          VLDR     s0,[r4,#0]            ;660
000104  ee200a00          VMUL.F32 s0,s0,s0              ;660
000108  edd40a01          VLDR     s1,[r4,#4]            ;660
00010c  ed941a01          VLDR     s2,[r4,#4]            ;660
000110  ee000a81          VMLA.F32 s0,s1,s2              ;660
000114  edd40a02          VLDR     s1,[r4,#8]            ;660
000118  ed941a02          VLDR     s2,[r4,#8]            ;660
00011c  ee000a81          VMLA.F32 s0,s1,s2              ;660
000120  eddf0abd          VLDR     s1,|L23.1048|
000124  ee801a20          VDIV.F32 s2,s0,s1              ;660
000128  48bc              LDR      r0,|L23.1052|
00012a  ed801a01          VSTR     s2,[r0,#4]            ;660
00012e  ed900a01          VLDR     s0,[r0,#4]            ;661
000132  eddf0abb          VLDR     s1,|L23.1056|
000136  eeb40ae0          VCMPE.F32 s0,s1                 ;661
00013a  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;661
00013e  dd0e              BLE      |L23.350|
000140  ed900a01          VLDR     s0,[r0,#4]            ;661
000144  eddf0ab7          VLDR     s1,|L23.1060|
000148  eeb40ae0          VCMPE.F32 s0,s1                 ;661
00014c  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;661
000150  d205              BCS      |L23.350|
000152  ed9f0ab5          VLDR     s0,|L23.1064|
000156  48b5              LDR      r0,|L23.1068|
000158  ed800a00          VSTR     s0,[r0,#0]            ;663
00015c  e004              B        |L23.360|
                  |L23.350|
00015e  ed9f0aab          VLDR     s0,|L23.1036|
000162  48b2              LDR      r0,|L23.1068|
000164  ed800a00          VSTR     s0,[r0,#0]            ;667
                  |L23.360|
000168  edd40a00          VLDR     s1,[r4,#0]            ;669
00016c  ee600aa0          VMUL.F32 s1,s1,s1              ;669
000170  ed941a01          VLDR     s2,[r4,#4]            ;669
000174  edd41a01          VLDR     s3,[r4,#4]            ;669
000178  ee410a21          VMLA.F32 s1,s2,s3              ;669
00017c  ed941a02          VLDR     s2,[r4,#8]            ;669
000180  edd41a02          VLDR     s3,[r4,#8]            ;669
000184  ee410a21          VMLA.F32 s1,s2,s3              ;669
000188  eeb00a60          VMOV.F32 s0,s1                 ;669
00018c  f7fffffe          BL       Invsqrt
000190  eeb08a40          VMOV.F32 s16,s0                ;669
000194  ed940a02          VLDR     s0,[r4,#8]            ;671
000198  ee200a08          VMUL.F32 s0,s0,s16             ;671
00019c  489f              LDR      r0,|L23.1052|
00019e  ed800a00          VSTR     s0,[r0,#0]            ;671
0001a2  ed900a00          VLDR     s0,[r0,#0]            ;672
0001a6  eddf0aa2          VLDR     s1,|L23.1072|
0001aa  eeb40ae0          VCMPE.F32 s0,s1                 ;672
0001ae  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;672
0001b2  d204              BCS      |L23.446|
0001b4  ed9f0a95          VLDR     s0,|L23.1036|
0001b8  ed800a02          VSTR     s0,[r0,#8]            ;674
0001bc  e00d              B        |L23.474|
                  |L23.446|
0001be  4897              LDR      r0,|L23.1052|
0001c0  edd00a02          VLDR     s1,[r0,#8]            ;678
0001c4  eeb00a60          VMOV.F32 s0,s1                 ;678
0001c8  f7fffffe          BL       __hardfp_acosf
0001cc  eeb0ba40          VMOV.F32 s22,s0                ;678
0001d0  f7fffffe          BL       __hardfp_sinf
0001d4  4891              LDR      r0,|L23.1052|
0001d6  ed800a02          VSTR     s0,[r0,#8]            ;678
                  |L23.474|
0001da  ed940a00          VLDR     s0,[r4,#0]            ;680
0001de  ee200a08          VMUL.F32 s0,s0,s16             ;680
0001e2  ed840a00          VSTR     s0,[r4,#0]            ;680
0001e6  ed940a01          VLDR     s0,[r4,#4]            ;681
0001ea  ee200a08          VMUL.F32 s0,s0,s16             ;681
0001ee  ed840a01          VSTR     s0,[r4,#4]            ;681
0001f2  ed940a02          VLDR     s0,[r4,#8]            ;682
0001f6  ee200a08          VMUL.F32 s0,s0,s16             ;682
0001fa  ed840a02          VSTR     s0,[r4,#8]            ;682
0001fe  ed9d0a05          VLDR     s0,[sp,#0x14]         ;684
000202  eddd0a07          VLDR     s1,[sp,#0x1c]         ;684
000206  ee300a60          VSUB.F32 s0,s0,s1              ;684
00020a  eef00a00          VMOV.F32 s1,#2.00000000        ;684
00020e  ee200a20          VMUL.F32 s0,s0,s1              ;684
000212  eeb09a40          VMOV.F32 s18,s0                ;684
000216  ed9d0a08          VLDR     s0,[sp,#0x20]         ;685
00021a  eddd0a03          VLDR     s1,[sp,#0xc]          ;685
00021e  ee300a20          VADD.F32 s0,s0,s1              ;685
000222  eef00a00          VMOV.F32 s1,#2.00000000        ;685
000226  ee200a20          VMUL.F32 s0,s0,s1              ;685
00022a  eef09a40          VMOV.F32 s19,s0                ;685
00022e  ed9d0a06          VLDR     s0,[sp,#0x18]         ;686
000232  ee7e0ac0          VSUB.F32 s1,s29,s0             ;686
000236  ed9d0a04          VLDR     s0,[sp,#0x10]         ;686
00023a  ee700ac0          VSUB.F32 s1,s1,s0              ;686
00023e  ed9d0a02          VLDR     s0,[sp,#8]            ;686
000242  ee300a80          VADD.F32 s0,s1,s0              ;686
000246  eeb0aa40          VMOV.F32 s20,s0                ;686
00024a  ed940a01          VLDR     s0,[r4,#4]            ;689
00024e  ee200a0a          VMUL.F32 s0,s0,s20             ;689
000252  edd40a02          VLDR     s1,[r4,#8]            ;689
000256  ee000ae9          VMLS.F32 s0,s1,s19             ;689
00025a  eef0aa40          VMOV.F32 s21,s0                ;689
00025e  ed940a02          VLDR     s0,[r4,#8]            ;690
000262  ee200a09          VMUL.F32 s0,s0,s18             ;690
000266  edd40a00          VLDR     s1,[r4,#0]            ;690
00026a  ee000aca          VMLS.F32 s0,s1,s20             ;690
00026e  eeb0da40          VMOV.F32 s26,s0                ;690
000272  ed940a00          VLDR     s0,[r4,#0]            ;691
000276  ee200a29          VMUL.F32 s0,s0,s19             ;691
00027a  edd40a01          VLDR     s1,[r4,#4]            ;691
00027e  ee000ac9          VMLS.F32 s0,s1,s18             ;691
000282  eef0da40          VMOV.F32 s27,s0                ;691
000286  486b              LDR      r0,|L23.1076|
000288  ed900a00          VLDR     s0,[r0,#0]            ;696
00028c  486a              LDR      r0,|L23.1080|
00028e  edd00a00          VLDR     s1,[r0,#0]            ;696
000292  ee0a0aa0          VMLA.F32 s0,s21,s1             ;696
000296  4867              LDR      r0,|L23.1076|
000298  ed800a00          VSTR     s0,[r0,#0]            ;696
00029c  4867              LDR      r0,|L23.1084|
00029e  ed900a00          VLDR     s0,[r0,#0]            ;697
0002a2  4865              LDR      r0,|L23.1080|
0002a4  edd00a00          VLDR     s1,[r0,#0]            ;697
0002a8  ee0d0a20          VMLA.F32 s0,s26,s1             ;697
0002ac  4863              LDR      r0,|L23.1084|
0002ae  ed800a00          VSTR     s0,[r0,#0]            ;697
0002b2  4863              LDR      r0,|L23.1088|
0002b4  ed900a00          VLDR     s0,[r0,#0]            ;698
0002b8  485f              LDR      r0,|L23.1080|
0002ba  edd00a00          VLDR     s1,[r0,#0]            ;698
0002be  ee0d0aa0          VMLA.F32 s0,s27,s1             ;698
0002c2  485f              LDR      r0,|L23.1088|
0002c4  ed800a00          VSTR     s0,[r0,#0]            ;698
0002c8  ed950a00          VLDR     s0,[r5,#0]            ;700
0002cc  4857              LDR      r0,|L23.1068|
0002ce  edd00a00          VLDR     s1,[r0,#0]            ;700
0002d2  ee000aaa          VMLA.F32 s0,s1,s21             ;700
0002d6  4857              LDR      r0,|L23.1076|
0002d8  edd00a00          VLDR     s1,[r0,#0]            ;700
0002dc  ee300a20          VADD.F32 s0,s0,s1              ;700
0002e0  ed850a00          VSTR     s0,[r5,#0]            ;700
0002e4  ed950a01          VLDR     s0,[r5,#4]            ;701
0002e8  4850              LDR      r0,|L23.1068|
0002ea  edd00a00          VLDR     s1,[r0,#0]            ;701
0002ee  ee000a8d          VMLA.F32 s0,s1,s26             ;701
0002f2  4852              LDR      r0,|L23.1084|
0002f4  edd00a00          VLDR     s1,[r0,#0]            ;701
0002f8  ee300a20          VADD.F32 s0,s0,s1              ;701
0002fc  ed850a01          VSTR     s0,[r5,#4]            ;701
000300  ed950a02          VLDR     s0,[r5,#8]            ;702
000304  4849              LDR      r0,|L23.1068|
000306  edd00a00          VLDR     s1,[r0,#0]            ;702
00030a  ee000aad          VMLA.F32 s0,s1,s27             ;702
00030e  484c              LDR      r0,|L23.1088|
000310  edd00a00          VLDR     s1,[r0,#0]            ;702
000314  ee300a20          VADD.F32 s0,s0,s1              ;702
000318  ed850a02          VSTR     s0,[r5,#8]            ;702
00031c  483c              LDR      r0,|L23.1040|
00031e  ed900a01          VLDR     s0,[r0,#4]            ;707
000322  eeb10a40          VNEG.F32 s0,s0                 ;707
000326  edd50a00          VLDR     s1,[r5,#0]            ;707
00032a  ee200a20          VMUL.F32 s0,s0,s1              ;707
00032e  edd00a02          VLDR     s1,[r0,#8]            ;707
000332  ed951a01          VLDR     s2,[r5,#4]            ;707
000336  ee000ac1          VMLS.F32 s0,s1,s2              ;707
00033a  edd00a03          VLDR     s1,[r0,#0xc]          ;707
00033e  ed951a02          VLDR     s2,[r5,#8]            ;707
000342  ee000ac1          VMLS.F32 s0,s1,s2              ;707
000346  ee200a28          VMUL.F32 s0,s0,s17             ;707
00034a  eef00a00          VMOV.F32 s1,#2.00000000        ;707
00034e  ee801a20          VDIV.F32 s2,s0,s1              ;707
000352  ed900a00          VLDR     s0,[r0,#0]            ;707
000356  ee310a00          VADD.F32 s0,s2,s0              ;707
00035a  ed800a00          VSTR     s0,[r0,#0]            ;707
00035e  ed900a00          VLDR     s0,[r0,#0]            ;708
000362  edd50a00          VLDR     s1,[r5,#0]            ;708
000366  ee200a20          VMUL.F32 s0,s0,s1              ;708
00036a  edd00a02          VLDR     s1,[r0,#8]            ;708
00036e  ed951a02          VLDR     s2,[r5,#8]            ;708
000372  ee000a81          VMLA.F32 s0,s1,s2              ;708
000376  edd00a03          VLDR     s1,[r0,#0xc]          ;708
00037a  ed951a01          VLDR     s2,[r5,#4]            ;708
00037e  ee000ac1          VMLS.F32 s0,s1,s2              ;708
000382  ee200a28          VMUL.F32 s0,s0,s17             ;708
000386  eeb01a00          VMOV.F32 s2,#2.00000000        ;708
00038a  eec00a01          VDIV.F32 s1,s0,s2              ;708
00038e  ed900a01          VLDR     s0,[r0,#4]            ;708
000392  ee300a80          VADD.F32 s0,s1,s0              ;708
000396  ed800a01          VSTR     s0,[r0,#4]            ;708
00039a  ed900a00          VLDR     s0,[r0,#0]            ;709
00039e  edd50a01          VLDR     s1,[r5,#4]            ;709
0003a2  ee200a20          VMUL.F32 s0,s0,s1              ;709
0003a6  edd00a01          VLDR     s1,[r0,#4]            ;709
0003aa  ed951a02          VLDR     s2,[r5,#8]            ;709
0003ae  ee000ac1          VMLS.F32 s0,s1,s2              ;709
0003b2  edd00a03          VLDR     s1,[r0,#0xc]          ;709
0003b6  ed951a00          VLDR     s2,[r5,#0]            ;709
0003ba  ee000a81          VMLA.F32 s0,s1,s2              ;709
0003be  ee200a28          VMUL.F32 s0,s0,s17             ;709
0003c2  eef00a00          VMOV.F32 s1,#2.00000000        ;709
0003c6  ee801a20          VDIV.F32 s2,s0,s1              ;709
0003ca  ed900a02          VLDR     s0,[r0,#8]            ;709
0003ce  ee310a00          VADD.F32 s0,s2,s0              ;709
0003d2  ed800a02          VSTR     s0,[r0,#8]            ;709
0003d6  ed900a00          VLDR     s0,[r0,#0]            ;710
0003da  edd50a02          VLDR     s1,[r5,#8]            ;710
0003de  ee200a20          VMUL.F32 s0,s0,s1              ;710
0003e2  edd00a01          VLDR     s1,[r0,#4]            ;710
0003e6  ed951a01          VLDR     s2,[r5,#4]            ;710
0003ea  ee000a81          VMLA.F32 s0,s1,s2              ;710
0003ee  edd00a02          VLDR     s1,[r0,#8]            ;710
0003f2  ed951a00          VLDR     s2,[r5,#0]            ;710
0003f6  ee000ac1          VMLS.F32 s0,s1,s2              ;710
0003fa  ee200a28          VMUL.F32 s0,s0,s17             ;710
0003fe  eef00a00          VMOV.F32 s1,#2.00000000        ;710
000402  ee801a20          VDIV.F32 s2,s0,s1              ;710
000406  ed900a03          VLDR     s0,[r0,#0xc]          ;710
00040a  e01b              B        |L23.1092|
                  |L23.1036|
00040c  00000000          DCFS     0x00000000 ; 0
                  |L23.1040|
                          DCD      q
                  |L23.1044|
000414  3ac49ba6          DCFS     0x3ac49ba6 ; 0.001500000013038516
                  |L23.1048|
000418  42c0147b          DCFS     0x42c0147b ; 96.040000915527344
                  |L23.1052|
                          DCD      Inerialacc
                  |L23.1056|
000420  3f0ccccd          DCFS     0x3f0ccccd ; 0.55000001192092896
                  |L23.1060|
000424  3f9ae148          DCFS     0x3f9ae148 ; 1.2100000381469727
                  |L23.1064|
000428  3f8b851f          DCFS     0x3f8b851f ; 1.0900000333786011
                  |L23.1068|
                          DCD      ||Kp||
                  |L23.1072|
000430  3d4ccccd          DCFS     0x3d4ccccd ; 0.05000000074505806
                  |L23.1076|
                          DCD      exInt
                  |L23.1080|
                          DCD      ||Ki||
                  |L23.1084|
                          DCD      eyInt
                  |L23.1088|
                          DCD      ezInt
                  |L23.1092|
000444  ee310a00          VADD.F32 s0,s2,s0              ;710
000448  ed800a03          VSTR     s0,[r0,#0xc]          ;710
00044c  edd00a00          VLDR     s1,[r0,#0]            ;712
000450  ee600aa0          VMUL.F32 s1,s1,s1              ;712
000454  ed901a01          VLDR     s2,[r0,#4]            ;712
000458  edd01a01          VLDR     s3,[r0,#4]            ;712
00045c  ee410a21          VMLA.F32 s1,s2,s3              ;712
000460  ed901a02          VLDR     s2,[r0,#8]            ;712
000464  edd01a02          VLDR     s3,[r0,#8]            ;712
000468  ee410a21          VMLA.F32 s1,s2,s3              ;712
00046c  ed901a03          VLDR     s2,[r0,#0xc]          ;712
000470  edd01a03          VLDR     s3,[r0,#0xc]          ;712
000474  ee410a21          VMLA.F32 s1,s2,s3              ;712
000478  eeb00a60          VMOV.F32 s0,s1                 ;712
00047c  f7fffffe          BL       Invsqrt
000480  eeb08a40          VMOV.F32 s16,s0                ;712
000484  4851              LDR      r0,|L23.1484|
000486  ed900a00          VLDR     s0,[r0,#0]            ;713
00048a  ee200a08          VMUL.F32 s0,s0,s16             ;713
00048e  ed800a00          VSTR     s0,[r0,#0]            ;713
000492  ed900a01          VLDR     s0,[r0,#4]            ;714
000496  ee200a08          VMUL.F32 s0,s0,s16             ;714
00049a  ed800a01          VSTR     s0,[r0,#4]            ;714
00049e  ed900a02          VLDR     s0,[r0,#8]            ;715
0004a2  ee200a08          VMUL.F32 s0,s0,s16             ;715
0004a6  ed800a02          VSTR     s0,[r0,#8]            ;715
0004aa  ed900a03          VLDR     s0,[r0,#0xc]          ;716
0004ae  ee200a08          VMUL.F32 s0,s0,s16             ;716
0004b2  ed800a03          VSTR     s0,[r0,#0xc]          ;716
0004b6  ed960a02          VLDR     s0,[r6,#8]            ;738
0004ba  ee6e0a28          VMUL.F32 s1,s28,s17            ;738
0004be  ed9f1a44          VLDR     s2,|L23.1488|
0004c2  ee000a81          VMLA.F32 s0,s1,s2              ;738
0004c6  ed860a02          VSTR     s0,[r6,#8]            ;738
0004ca  edd00a01          VLDR     s1,[r0,#4]            ;739
0004ce  eeb81a00          VMOV.F32 s2,#-2.00000000       ;739
0004d2  ee600a81          VMUL.F32 s1,s1,s2              ;739
0004d6  ed901a03          VLDR     s2,[r0,#0xc]          ;739
0004da  ee600a81          VMUL.F32 s1,s1,s2              ;739
0004de  ed901a00          VLDR     s2,[r0,#0]            ;739
0004e2  eef01a00          VMOV.F32 s3,#2.00000000        ;739
0004e6  ee211a21          VMUL.F32 s2,s2,s3              ;739
0004ea  edd01a02          VLDR     s3,[r0,#8]            ;739
0004ee  ee410a21          VMLA.F32 s1,s2,s3              ;739
0004f2  eeb00a60          VMOV.F32 s0,s1                 ;739
0004f6  f7fffffe          BL       __hardfp_sinf
0004fa  ee107a10          VMOV     r7,s0                 ;739
0004fe  4638              MOV      r0,r7                 ;739
000500  f7fffffe          BL       __aeabi_f2d
000504  ec410b1c          VMOV     d12,r0,r1             ;739
000508  ed9f0b32          VLDR     d0,|L23.1492|
00050c  ec532b10          VMOV     r2,r3,d0              ;739
000510  f7fffffe          BL       __aeabi_dmul
000514  ec410b1b          VMOV     d11,r0,r1             ;739
000518  f7fffffe          BL       __aeabi_d2f
00051c  6030              STR      r0,[r6,#0]            ;739
00051e  482b              LDR      r0,|L23.1484|
000520  ed900a01          VLDR     s0,[r0,#4]            ;740
000524  eef80a00          VMOV.F32 s1,#-2.00000000       ;740
000528  ee200a20          VMUL.F32 s0,s0,s1              ;740
00052c  edd00a01          VLDR     s1,[r0,#4]            ;740
000530  ee200a20          VMUL.F32 s0,s0,s1              ;740
000534  edd00a02          VLDR     s1,[r0,#8]            ;740
000538  eeb01a00          VMOV.F32 s2,#2.00000000        ;740
00053c  ee600a81          VMUL.F32 s1,s1,s2              ;740
000540  ed901a02          VLDR     s2,[r0,#8]            ;740
000544  ee000ac1          VMLS.F32 s0,s1,s2              ;740
000548  eef70a00          VMOV.F32 s1,#1.00000000        ;740
00054c  ee300a20          VADD.F32 s0,s0,s1              ;740
000550  ee101a10          VMOV     r1,s0                 ;740
000554  4608              MOV      r0,r1                 ;740
000556  f7fffffe          BL       __aeabi_f2d
00055a  ec410b1f          VMOV     d15,r0,r1             ;740
00055e  481b              LDR      r0,|L23.1484|
000560  ed900a02          VLDR     s0,[r0,#8]            ;740
000564  eef00a00          VMOV.F32 s1,#2.00000000        ;740
000568  ee200a20          VMUL.F32 s0,s0,s1              ;740
00056c  edd00a03          VLDR     s1,[r0,#0xc]          ;740
000570  ee200a20          VMUL.F32 s0,s0,s1              ;740
000574  edd00a00          VLDR     s1,[r0,#0]            ;740
000578  eeb01a00          VMOV.F32 s2,#2.00000000        ;740
00057c  ee600a81          VMUL.F32 s1,s1,s2              ;740
000580  ed901a01          VLDR     s2,[r0,#4]            ;740
000584  ee000a81          VMLA.F32 s0,s1,s2              ;740
000588  ee101a10          VMOV     r1,s0                 ;740
00058c  4608              MOV      r0,r1                 ;740
00058e  f7fffffe          BL       __aeabi_f2d
000592  eeb01a4f          VMOV.F32 s2,s30                ;740
000596  eef01a6f          VMOV.F32 s3,s31                ;740
00059a  e9cd0100          STRD     r0,r1,[sp,#0]         ;740
00059e  ed9d0b00          VLDR     d0,[sp,#0]            ;740
0005a2  f7fffffe          BL       __hardfp_atan2
0005a6  eeb0ba40          VMOV.F32 s22,s0                ;740
0005aa  eef0ba60          VMOV.F32 s23,s1                ;740
0005ae  ed9f0b09          VLDR     d0,|L23.1492|
0005b2  ec532b10          VMOV     r2,r3,d0              ;740
0005b6  ec510b1b          VMOV     r0,r1,d11             ;740
0005ba  f7fffffe          BL       __aeabi_dmul
0005be  ec410b1c          VMOV     d12,r0,r1             ;740
0005c2  f7fffffe          BL       __aeabi_d2f
0005c6  6070              STR      r0,[r6,#4]            ;740
0005c8  bf00              NOP      
0005ca  e58a              B        |L23.226|
;;;745    
                          ENDP

                  |L23.1484|
                          DCD      q
                  |L23.1488|
0005d0  42653333          DCFS     0x42653333 ; 57.299999237060547
                  |L23.1492|
0005d4  66666666          DCFD     0x404ca66666666666 ; 57.299999999999997
0005d8  404ca666

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OffSet
                          %        12
                  acc
                          %        12
                  velocity
                          %        12
                  ACC
                          %        12
                  VELOCITY
                          %        12
                  KalmanfilterAccx
                          %        28
                  KalmanfilterAccy
                          %        28
                  KalmanfilterAccz
                          %        28
                  Eulla
                          %        12
                  Inerialacc
                          %        12
                  ACC_TEMP
                          %        12
                  BUF4
                          %        12
                  BUF5
                          %        12
                  BUF6
                          %        12
                  BUF1
                          %        12
                  BUF2
                          %        12
                  BUF3
                          %        12
                  |symbol_number.70|
                          %        12
                  |symbol_number.71|
                          %        12
                  |symbol_number.72|
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  offsetlength
000000  64000000          DCB      0x64,0x00,0x00,0x00
                  acc_denominator
000004  43d0f99a          DCFS     0x43d0f99a ; 417.95001220703125
                  gyro_denominator
000008  44eaa666          DCFS     0x44eaa666 ; 1877.199951171875
                  accfilter_Num
00000c  06                DCB      0x06
                  gyrofilter_Num
00000d  060000            DCB      0x06,0x00,0x00
                  gyroscale
000010  462ffccc          DCFS     0x462ffccc ; 11263.19921875

                          AREA ||.data||, DATA, ALIGN=2

                  Sensor_Acc
                          DCD      0x00000000
000004  0000              DCB      0x00,0x00
                  Sensor_Gyro
000006  0000              DCB      0x00,0x00
                          DCD      0x00000000
                  ||Kp||
00000c  3f8b851f          DCFS     0x3f8b851f ; 1.0900000333786011
                  ||Ki||
000010  3a83126f          DCFS     0x3a83126f ; 0.0010000000474974513
                  exInt
000014  00000000          DCFS     0x00000000 ; 0
                  eyInt
000018  00000000          DCFS     0x00000000 ; 0
                  ezInt
00001c  00000000          DCFS     0x00000000 ; 0
                  q
000020  3f800000          DCFS     0x3f800000 ; 1
000024  00000000          DCFS     0x00000000 ; 0
000028  00000000          DCFS     0x00000000 ; 0
00002c  00000000          DCFS     0x00000000 ; 0
                  counter
000030  00                DCB      0x00
                  count
000031  00                DCB      0x00
                  |symbol_number.78|
000032  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\MySrc\\MPU6050\\mpu6050.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu6050_c_Invsqrt____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_mpu6050_c_Invsqrt____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu6050_c_Invsqrt____REVSH|
#line 144
|__asm___9_mpu6050_c_Invsqrt____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu6050_c_Invsqrt____RRX|
#line 300
|__asm___9_mpu6050_c_Invsqrt____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
